<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>todooutcome</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="cartesian-product-definition">Cartesian
product definition</h1>
<p><span><strong>Definition</strong></span>: The <span><strong>Cartesian
product</strong></span> of the sets <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span>, <span class="math inline">\(A \times
B\)</span>, is the set of all ordered pairs <span
class="math inline">\((a, b)\)</span>, where <span
class="math inline">\(a \in A\)</span> and <span class="math inline">\(b
\in B\)</span>. That is: <span class="math inline">\(A \times B = \{(a,
b) \mid (a \in A) \land (b \in B)\}\)</span>. The Cartesian product of
the sets <span class="math inline">\(A_1, A_2, \ldots ,A_n\)</span>,
denoted by <span class="math inline">\(A_1 \times A_2 \times \cdots
\times A_n\)</span>, is the set of ordered n-tuples <span
class="math inline">\((a_1, a_2,...,a_n)\)</span>, where <span
class="math inline">\(a_i\)</span> belongs to <span
class="math inline">\(A_i\)</span> for <span class="math inline">\(i =
1, 2,\ldots,n\)</span>. That is, <span class="math display">\[A_1 \times
A_2 \times \cdots \times A_n = \{(a_1, a_2,\ldots,a_n) \mid a_i \in A_i
\textrm{ for } i = 1, 2,\ldots,n\}\]</span></p>
<h1 class="unnumbered" id="rna-mutation-insertion-deletion-example">Rna
mutation insertion deletion example</h1>
<p>Trace the pseudocode to find the output of <span
class="math inline">\(\textit{mutation}(~
(\texttt{A}\texttt{U}\texttt{C}, 3, \texttt{G}) ~)\)</span></p>
<p>Fill in the blanks so that <span
class="math inline">\(\textit{insertion}(~(\texttt{A}\texttt{U}\texttt{C},
\underline{\phantom{3}}, \underline{\phantom{\texttt{G}}})~) =
\texttt{A}\texttt{U}\texttt{C}\texttt{G}\)</span></p>
<p>Fill in the blanks so that <span
class="math inline">\(\textit{deletion}(~(\underline{\phantom{\texttt{G}\texttt{G}}},
\underline{\phantom{1}})~) =  \texttt{G}\)</span></p>
<h1 class="unnumbered" id="rna-rnalen-basecount-definitions">Rna rnalen
basecount definitions</h1>
<p><span><em>Recall the definitions</em></span>: The set of RNA strands
<span class="math inline">\(S\)</span> is defined (recursively) by:
<span class="math display">\[\begin{array}{ll}
\textrm{Basis Step: } &amp; \texttt{A}\in S, \texttt{C}\in S,
\texttt{U}\in S, \texttt{G}\in S \\
\textrm{Recursive Step: } &amp; \textrm{If } s \in S\textrm{ and }b \in
B \textrm{, then }sb \in S
\end{array}\]</span> where <span class="math inline">\(sb\)</span> is
string concatenation.</p>
<p>The function <em>rnalen</em> that computes the length of RNA strands
in <span class="math inline">\(S\)</span> is defined recursively by:
<span class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{rnalen} : S &amp; \to \mathbb{Z}^+ \\
\textrm{Basis Step:} &amp; \textrm{If } b \in B\textrm{ then } &amp;
\textit{rnalen}(b) &amp; = 1 \\
\textrm{Recursive Step:} &amp; \textrm{If } s \in S\textrm{ and }b \in
B\textrm{, then  } &amp; \textit{rnalen}(sb) &amp; = 1 +
\textit{rnalen}(s)
\end{array}\]</span></p>
<p>The function <em>basecount</em> that computes the number of a given
base <span class="math inline">\(b\)</span> appearing in a RNA strand
<span class="math inline">\(s\)</span> is defined recursively by: <span
class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{basecount} : S \times B &amp; \to \mathbb{N} \\
\textrm{Basis Step:} &amp;  \textrm{If } b_1 \in B, b_2 \in B &amp;
\textit{basecount}(~(b_1, b_2)~) &amp; =
        \begin{cases}
            1 &amp; \textrm{when } b_1 = b_2 \\
            0 &amp; \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} &amp; \textrm{If } s \in S, b_1 \in B, b_2 \in
B &amp;\textit{basecount}(~(s b_1, b_2)~) &amp; =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) &amp; \textrm{when } b_1
= b_2 \\
            \textit{basecount}(~(s, b_2)~) &amp; \textrm{when } b_1 \neq
b_2 \\
        \end{cases}
\end{array}\]</span></p>
<h1 class="unnumbered"
id="alternating-quantifiers-order-rna-examples">Alternating quantifiers
order rna examples</h1>
<p><span><strong>Alternating nested quantifiers</strong></span></p>
<p><span class="math display">\[\forall s \in S ~\exists n \in
\mathbb{N} ~(~basecount(~(s,\texttt{U})~) = n~)\]</span></p>
<p>In English: For each strand, there is a nonnnegative integer that
counts the number of occurrences of <span
class="math inline">\(\texttt{U}\)</span> in that strand.<br />
<span class="math display">\[\exists n \in \mathbb{N} ~\forall s \in S
~(~basecount(~(s,\texttt{U})~) = n~)\]</span></p>
<p>In English: There is a nonnnegative integer that counts the number of
occurrences of <span class="math inline">\(\texttt{U}\)</span> in every
strand.<br />
</p>
<p>Are these statements true or false?</p>
<p><span class="math display">\[\forall s \in S ~\exists b\in B
~(~basecount(~(s,b)~) = 3~)\]</span></p>
<p>In English: For each RNA strand there is a base that occurs 3 times
in this strand.<br />
Write the negation and use De Morgan’s law to find a logically
equivalent version where the negation is applied only to the <span
class="math inline">\(BC\)</span> predicate (not next to a
quantifier).</p>
<p>Is the original statement <span><strong>True</strong></span> or
<span><strong>False</strong></span>?</p>
<h1 class="unnumbered"
id="proof-strategies-quantification-finite-domain">Proof strategies
quantification finite domain</h1>
<p>When a predicate <span class="math inline">\(P(x)\)</span> is over a
<span><strong>finite</strong></span> domain:</p>
<ul>
<li><p>To show that <span class="math inline">\(\forall x  P(x)\)</span>
is true: check that <span class="math inline">\(P(x)\)</span> evaluates
to <span class="math inline">\(T\)</span> at each domain element by
evaluating over and over. This is called “Proof of universal by
<span><strong>exhaustion</strong></span>".</p></li>
<li><p>To show that <span class="math inline">\(\forall x  P(x)\)</span>
is false: find a <span><strong>counterexample</strong></span>, a domain
element where <span
class="math inline">\(P(x)\)</span> evaluates to <span
class="math inline">\(F\)</span>.</p></li>
<li><p>To show that <span class="math inline">\(\exists x  P(x)\)</span>
is true: find a <span><strong>witness</strong></span>, a domain element
where <span class="math inline">\(P(x)\)</span> evaluates to <span
class="math inline">\(T\)</span>.</p></li>
<li><p>To show that <span class="math inline">\(\exists x  P(x)\)</span>
is false: check that <span class="math inline">\(P(x)\)</span> evaluates
to <span class="math inline">\(F\)</span> at each domain element by
evaluating over and over. DeMorgan’s Law gives that <span
class="math inline">\(\lnot \exists x P(x) ~~\equiv~~ \forall x \lnot
P(x)\)</span> so this amounts to a proof of universal by
exhaustion.</p></li>
</ul>
<h1 class="unnumbered"
id="proof-strategy-universal-generalization">Proof strategy universal
generalization</h1>
<h1 class="unnumbered" id="quiz-translating-counting-quantifiers">Quiz
translating counting quantifiers</h1>
<p>Suppose <span class="math inline">\(P(x)\)</span> is a predicate over
a domain <span class="math inline">\(D\)</span>.</p>
<ol>
<li><p>True or False: To translate the statement “There are at least two
elements in <span class="math inline">\(D\)</span> where the predicate
<span class="math inline">\(P\)</span> evaluates to true", we could
write <span class="math display">\[\exists  x_1 \in D \, \exists x_2 \in
D  \, (P(x_1) \wedge P(x_2))\]</span></p></li>
<li><p>True or False: To translate the statement “There are at most two
elements in <span class="math inline">\(D\)</span> where the predicate
<span class="math inline">\(P\)</span> evaluates to true", we could
write <span class="math display">\[\forall  x_1 \in D \, \forall x_2 \in
D \, \forall x_3 \in  D \, \left(~ (~P(x_1) \wedge P(x_2)  \wedge P(x_3)
~) \to (~ x_1 = x_2 \vee x_2 = x_3 \vee x_1 =
x_3~)~\right)\]</span></p></li>
</ol>
<h1 class="unnumbered" id="proof-strategies-conditionals">Proof
strategies conditionals</h1>
<h1 class="unnumbered" id="proof-strategies-proof-by-cases">Proof
strategies proof by cases</h1>
<h1 class="unnumbered" id="proof-strategies-ands">Proof strategies
ands</h1>
<h1 class="unnumbered" id="sets-proof-strategies">Sets proof
strategies</h1>
<p>To prove that one set is a subset of another, e.g. to show <span
class="math inline">\(A \subseteq B\)</span>:</p>
<p>To prove that two sets are equal, e.g. to show <span
class="math inline">\(A = B\)</span>:</p>
<h1 class="unnumbered" id="sets-equality-example">Sets equality
example</h1>
<p>Example: <span class="math inline">\(\{ 43, 7, 9 \} = \{ 7, 43, 9,
7\}\)</span></p>
<h1 class="unnumbered" id="sets-basic-proofs">Sets basic proofs</h1>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: <span class="math inline">\(\{
\texttt{A},  \texttt{C},  \texttt{U},  \texttt{G}\} \subseteq \{
\texttt{A}\texttt{A}, \texttt{A}\texttt{C}, \texttt{A}\texttt{U},
\texttt{A}\texttt{G}\}\)</span></p>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: For some set <span
class="math inline">\(B\)</span>, <span class="math inline">\(\emptyset
\in B\)</span>.</p>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: For every set <span
class="math inline">\(B\)</span>, <span class="math inline">\(\emptyset
\in B\)</span>.</p>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: The empty set is a subset of
every set.</p>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: The empty set is a proper subset
of every set.</p>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: <span class="math inline">\(\{
4, 6 \} \subseteq \{ n \mid  \exists c \in \mathbb{Z} ( n = 4c)
\}\)</span></p>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: <span class="math inline">\(\{
4, 6 \} \subseteq \{ n ~\textbf{mod}~10 \mid  \exists c \in \mathbb{Z} (
n = 4c) \}\)</span></p>
<h1 class="unnumbered" id="proofs-signposting">Proofs signposting</h1>
<h1 class="unnumbered"
id="set-operations-union-intersection-powerset">Set operations union
intersection powerset</h1>
<p><span><strong>Cartesian product</strong></span>: When <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span> are sets, <span
class="math display">\[A \times  B = \{ (a,b) \mid a \in A  \wedge
b  \in B \}\]</span></p>
<p>Example: <span class="math inline">\(\{43, 9\} \times  \{9,
\mathbb{Z}\}  =\)</span></p>
<p>Example: <span class="math inline">\(\mathbb{Z} \times
\emptyset  =\)</span></p>
<p><span><strong>Union</strong></span>: When <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span> are sets, <span
class="math display">\[A \cup  B = \{ x \mid x \in A  \vee x \in B
\}\]</span></p>
<p>Example: <span class="math inline">\(\{43, 9\} \cup \{9,
\mathbb{Z}\}  =\)</span></p>
<p>Example: <span class="math inline">\(\mathbb{Z} \cup
\emptyset  =\)</span></p>
<p><span><strong>Intersection</strong></span>: When <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span> are sets, <span
class="math display">\[A \cap  B = \{ x \mid x \in A  \wedge x \in B
\}\]</span> Example: <span class="math inline">\(\{43, 9\} \cap
\{9,\mathbb{Z}\}  =\)</span></p>
<p>Example: <span class="math inline">\(\mathbb{Z} \cap
\emptyset  =\)</span></p>
<p><span><strong>Set difference</strong></span>: When <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span> are sets,</p>
<p><span class="math display">\[A -  B = \{ x \mid x \in A  \wedge x
\notin B \}\]</span></p>
<p>Example: <span class="math inline">\(\{43, 9\} - \{9,
\mathbb{Z}\}  =\)</span></p>
<p>Example: <span class="math inline">\(\mathbb{Z} -
\emptyset  =\)</span></p>
<p><span><strong>Disjoint sets</strong></span>: sets <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span> are disjoint means <span
class="math inline">\(A \cap  B  = \emptyset\)</span></p>
<p>Example: <span class="math inline">\(\{43, 9\}, \{9,
\mathbb{Z}\}\)</span> are not disjoint</p>
<p>Example: The sets <span class="math inline">\(\mathbb{Z}\)</span> and
<span class="math inline">\(\emptyset\)</span> are disjoint</p>
<p><span><strong>Power set</strong></span>: When <span
class="math inline">\(U\)</span> is a set, <span
class="math inline">\(\mathcal{P}(U) = \{ X \mid X \subseteq
U\}\)</span></p>
<p>Example: <span class="math inline">\(\mathcal{P}(\{43, 9\})
=\)</span></p>
<p>Example: <span class="math inline">\(\mathcal{P}(\emptyset)
=\)</span></p>
<h1 class="unnumbered" id="quantification-definition">Quantification
definition</h1>
<p>The <span><strong>universal quantification</strong></span> of
predicate <span class="math inline">\(P(x)\)</span> over domain <span
class="math inline">\(U\)</span> is the statement “<span
class="math inline">\(P(x)\)</span> for all values of <span
class="math inline">\(x\)</span> in the domain <span
class="math inline">\(U\)</span>” and is written <span
class="math inline">\(\forall x P(x)\)</span> or <span
class="math inline">\(\forall x \in U ~P(x)\)</span>. When the domain is
finite, universal quantification over the domain is equivalent to
iterated <span><em>conjunction</em></span> (ands).</p>
<p>The <span><strong>existential quantification</strong></span> of
predicate <span class="math inline">\(P(x)\)</span> over domain <span
class="math inline">\(U\)</span> is the statement “There exists an
element <span class="math inline">\(x\)</span> in the domain <span
class="math inline">\(U\)</span> such that <span
class="math inline">\(P(x)\)</span>” and is written <span
class="math inline">\(\exists x P(x)\)</span> for <span
class="math inline">\(\exists x \in U ~P(x)\)</span>. When the domain is
finite, existential quantification over the domain is equivalent to
iterated <span><em>disjunction</em></span> (ors).</p>
<p>An element for which <span class="math inline">\(P(x) = F\)</span> is
called a <span><strong>counterexample</strong></span> of <span
class="math inline">\(\forall x P(x)\)</span>.</p>
<p>An element for which <span class="math inline">\(P(x) = T\)</span> is
called a <span><strong>witness</strong></span> of <span
class="math inline">\(\exists x P(x)\)</span>.</p>
<h1 class="unnumbered"
id="quantification-logical-equivalence">Quantification logical
equivalence</h1>
<p>Statements involving predicates and quantifiers are
<span><strong>logically equivalent</strong></span> means they have the
same truth value no matter which predicates (domains and functions) are
substituted in.</p>
<p><span><strong>Quantifier version of De Morgan’s laws</strong></span>:
<span class="math inline">\(\boxed{\neg \forall x P(x) ~\equiv~ \exists
x \left( \neg P(x) \right)}\)</span> <span
class="math inline">\(\boxed{\neg \exists x Q(x) ~\equiv~ \forall x
\left( \neg Q(x) \right)}\)</span></p>
<h1 class="unnumbered"
id="quantification-examples-finite-domain">Quantification examples
finite domain</h1>
<p>Examples of quantifications using <span class="math inline">\(V(x),
N(x), Mystery(x)\)</span>:</p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span class="math inline">\(\exists
x~ (~V(x) \land N(x)~)\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span class="math inline">\(\forall
x~ (~V(x) \to N(x)~)\)</span></p>
<p><span><strong>True</strong></span> or
<span><strong>False</strong></span>: <span class="math inline">\(\exists
x~ (~N(x) \leftrightarrow Mystery(x)~)\)</span></p>
<p>Rewrite <span class="math inline">\(\lnot \forall x~(~V(x) \oplus
Mystery(x)~)\)</span> into a logical equivalent statement.</p>
<p>Notice that these are examples where the predicates have
<span><em>finite</em></span> domain. How would we evaluate
quantifications where the domain may be infinite?</p>
<h1 class="unnumbered" id="rna-rnalen-basecount-definitions-1">Rna
rnalen basecount definitions</h1>
<p><span><em>Recall the definitions</em></span>: The set of RNA strands
<span class="math inline">\(S\)</span> is defined (recursively) by:
<span class="math display">\[\begin{array}{ll}
\textrm{Basis Step: } &amp; \texttt{A}\in S, \texttt{C}\in S,
\texttt{U}\in S, \texttt{G}\in S \\
\textrm{Recursive Step: } &amp; \textrm{If } s \in S\textrm{ and }b \in
B \textrm{, then }sb \in S
\end{array}\]</span> where <span class="math inline">\(sb\)</span> is
string concatenation.</p>
<p>The function <em>rnalen</em> that computes the length of RNA strands
in <span class="math inline">\(S\)</span> is defined recursively by:
<span class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{rnalen} : S &amp; \to \mathbb{Z}^+ \\
\textrm{Basis Step:} &amp; \textrm{If } b \in B\textrm{ then } &amp;
\textit{rnalen}(b) &amp; = 1 \\
\textrm{Recursive Step:} &amp; \textrm{If } s \in S\textrm{ and }b \in
B\textrm{, then  } &amp; \textit{rnalen}(sb) &amp; = 1 +
\textit{rnalen}(s)
\end{array}\]</span></p>
<p>The function <em>basecount</em> that computes the number of a given
base <span class="math inline">\(b\)</span> appearing in a RNA strand
<span class="math inline">\(s\)</span> is defined recursively by: <span
class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{basecount} : S \times B &amp; \to \mathbb{N} \\
\textrm{Basis Step:} &amp;  \textrm{If } b_1 \in B, b_2 \in B &amp;
\textit{basecount}(~(b_1, b_2)~) &amp; =
        \begin{cases}
            1 &amp; \textrm{when } b_1 = b_2 \\
            0 &amp; \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} &amp; \textrm{If } s \in S, b_1 \in B, b_2 \in
B &amp;\textit{basecount}(~(s b_1, b_2)~) &amp; =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) &amp; \textrm{when } b_1
= b_2 \\
            \textit{basecount}(~(s, b_2)~) &amp; \textrm{when } b_1 \neq
b_2 \\
        \end{cases}
\end{array}\]</span></p>
<h1 class="unnumbered"
id="predicates-example-rnalen-basecount">Predicates example rnalen
basecount</h1>
<p><span><strong>Using functions to define
predicates</strong></span>:</p>
<p>Example where <span class="math inline">\(L\)</span> evaluates to
<span class="math inline">\(T\)</span>: <span
class="math inline">\(\underline{\phantom{(\texttt{A},
1)\hspace{1in}}}\)</span> Why?</p>
<p>Example where <span class="math inline">\(BC\)</span> evaluates to
<span class="math inline">\(T\)</span>: <span
class="math inline">\(\underline{\phantom{(\texttt{A},
\texttt{A}1)\hspace{1in}}}\)</span> Why?</p>
<p>Example where <span class="math inline">\(L\)</span> evaluates to
<span class="math inline">\(F\)</span>: <span
class="math inline">\(\underline{\phantom{(\texttt{A},
2)\hspace{1in}}}\)</span> Why?</p>
<p>Example where <span class="math inline">\(BC\)</span> evaluates to
<span class="math inline">\(F\)</span>: <span
class="math inline">\(\underline{\phantom{(\texttt{A}, \texttt{C},
1)\hspace{1in}}}\)</span> Why?</p>
<h1 class="unnumbered"
id="predicates-projecting-example-rna-basecount">Predicates projecting
example rna basecount</h1>
<p><span><strong>New predicates from old</strong></span></p>
<ol>
<li><p>Define the <span><strong>new</strong></span> predicate with
domain <span class="math inline">\(S \times B\)</span> and rule <span
class="math display">\[basecount(~(s,b)~) = 3\]</span> Example domain
element where predicate is <span class="math inline">\(T\)</span>:<br />
</p></li>
<li><p>Define the <span><strong>new</strong></span> predicate with
domain <span class="math inline">\(S \times \mathbb{N}\)</span> and rule
<span class="math display">\[basecount(~(s,\texttt{A})~) = n\]</span>
Example domain element where predicate is <span
class="math inline">\(T\)</span>:<br />
</p></li>
<li><p>Define the <span><strong>new</strong></span> predicate with
domain <span class="math inline">\(S \times B\)</span> and rule <span
class="math display">\[\exists n \in \mathbb{N} ~(basecount(~(s,b)~) =
n)\]</span> Example domain element where predicate is <span
class="math inline">\(T\)</span>:<br />
</p></li>
<li><p>Define the <span><strong>new</strong></span> predicate with
domain <span class="math inline">\(S\)</span> and rule <span
class="math display">\[\forall b \in B ~(basecount(~(s,b)~) =
1)\]</span> Example domain element where predicate is <span
class="math inline">\(T\)</span>:<br />
</p></li>
</ol>
<h1 class="unnumbered" id="nested-quantifiers">Nested quantifiers</h1>
<p><span><strong>Nested quantifiers</strong></span></p>
<h1 class="unnumbered"
id="alternating-quantifiers-strategies-rna-examples">Alternating
quantifiers strategies rna examples</h1>
<p><span><strong>Alternating nested quantifiers</strong></span></p>
<h1 class="unnumbered" id="sets-proof-strategies-1">Sets proof
strategies</h1>
<p>To prove that one set is a subset of another, e.g. to show <span
class="math inline">\(A \subseteq B\)</span>:</p>
<p>To prove that two sets are equal, e.g. to show <span
class="math inline">\(A = B\)</span>:</p>
<h1 class="unnumbered" id="sets-basic-proofs-operations">Sets basic
proofs operations</h1>
<p>Let <span class="math inline">\(W =  \mathcal{P}(  \{ 1,2,3,4,5\}
)\)</span></p>
<p>Example elements in <span class="math inline">\(W\)</span> are:</p>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: <span
class="math inline">\(\forall  A \in W\,  \forall B \in W\,  \left( A
\subseteq B
~\to ~ \mathcal{P}(A) \subseteq \mathcal{P}(B) \right)\)</span></p>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: <span
class="math inline">\(\forall  A \in W\,  \forall B \in W\,  \left(
\mathcal{P}(A)  =\mathcal{P}(B)
~\to ~ A = B \right)\)</span></p>
<p><span><strong>Prove</strong></span> or
<span><strong>disprove</strong></span>: <span
class="math inline">\(\forall  A \in W\,  \forall B \in W\, \forall
C  \in W\,  \left( A\cup B  = A \cup  C
~\to ~ B = C \right)\)</span></p>
<h1 class="unnumbered" id="proof-strategies-road-map">Proof strategies
road map</h1>
<p>We now have propositional and predicate logic that can help us
express statements about any domain. We will develop proof strategies to
craft valid argument for proving that such statements are true or
disproving them (by showing they are false). We will practice these
strategies with statements about sets and numbers, both because they are
familiar and because they can be used to build cryptographic systems.
Then we will apply proof strategies more broadly to prove statements
about data structures and machine learning applications.</p>
<h1 class="unnumbered" id="numbers-facts">Numbers facts</h1>
<ol>
<li><p>Addition and multiplication of real numbers are each commutative
and associative.</p></li>
<li><p>The product of two positive numbers is positive, of two negative
numbers is positive, and of a positive and a negative number is
negative.</p></li>
<li><p>The sum of two integers, the product of two integers, and the
difference between two integers are each integers.</p></li>
<li><p>For every integer <span class="math inline">\(x\)</span> there is
no integer strictly between <span class="math inline">\(x\)</span> and
<span class="math inline">\(x+1\)</span>,</p></li>
<li><p>When <span class="math inline">\(x, y\)</span> are positive
integers, <span class="math inline">\(xy \geq x\)</span> and <span
class="math inline">\(xy \geq y\)</span>.</p></li>
</ol>
<h1 class="unnumbered" id="factoring-definition">Factoring
definition</h1>
<p><span><strong>Definition</strong></span>: When <span
class="math inline">\(a\)</span> and <span
class="math inline">\(b\)</span> are integers and <span
class="math inline">\(a\)</span> is nonzero, <span><strong><span
class="math inline">\(a\)</span> divides <span
class="math inline">\(b\)</span></strong></span> means there is an
integer <span class="math inline">\(c\)</span> such that <span
class="math inline">\(b = ac\)</span> .</p>
<p>Symbolically, <span class="math inline">\(F(~(a,b)~) =
\phantom{\exists c\in \mathbb{Z}~(b=ac)}\)</span> and is a predicate
over the domain <u></u></p>
<p>Other (synonymous) ways to say that <span
class="math inline">\(F(~(a,b)~)\)</span> is true:</p>
<div class="center">
<p><span class="math inline">\(a\)</span> is a
<span><strong>factor</strong></span> of <span
class="math inline">\(b\)</span> <span class="math inline">\(a\)</span>
is a <span><strong>divisor</strong></span> of <span
class="math inline">\(b\)</span> <span class="math inline">\(b\)</span>
is a <span><strong>multiple</strong></span> of <span
class="math inline">\(a\)</span> <span class="math inline">\(a |
b\)</span></p>
</div>
<p>When <span class="math inline">\(a\)</span> is a positive integer and
<span class="math inline">\(b\)</span> is any integer, <span
class="math inline">\(a | b\)</span> exactly when <span
class="math inline">\(b \textbf{ mod } a = 0\)</span></p>
<p>When <span class="math inline">\(a\)</span> is a positive integer and
<span class="math inline">\(b\)</span> is any integer, <span
class="math inline">\(a | b\)</span> exactly <span
class="math inline">\(b = a \cdot (b \textbf{ div } a)\)</span></p>
<h1 class="unnumbered" id="factoring-translation-examples">Factoring
translation examples</h1>
<p><span><em>Translate these quantified statements by matching to
English statement on right.</em></span></p>
<div class="multicols">
<p><span>2</span> <span class="math inline">\(\exists a\in
\mathbb{Z}^{\neq 0} ~(~F(~(a,a)~)~)\)</span></p>
<p><span class="math inline">\(\exists a\in \mathbb{Z}^{\neq 0} ~(~\lnot
F(~(a,a)~)~)\)</span></p>
<p><span class="math inline">\(\forall a\in \mathbb{Z}^{\neq 0}
~(~F(~(a,a)~)~)\)</span></p>
<p><span class="math inline">\(\forall a\in \mathbb{Z}^{\neq 0} ~(~\lnot
F(~(a,a)~)~)\)</span></p>
<p>Every nonzero integer is a factor of itself.</p>
<p>No nonzero integer is a factor of itself.</p>
<p>At least one nonzero integer is a factor of itself.</p>
<p>Some nonzero integer is not a factor of itself.</p>
</div>
<h1 class="unnumbered" id="factoring-basic-claims">Factoring basic
claims</h1>
<p><span><strong>Claim</strong></span>: Every nonzero integer is a
factor of itself.</p>
<p><span><strong>Proof</strong></span>:</p>
<p><span><strong>Prove</strong></span> or
<span><strong>Disprove</strong></span>: There is a nonzero integer that
does not divide its square.</p>
<p><span><strong>Prove</strong></span> or
<span><strong>Disprove</strong></span>: Every positive factor of a
positive integer is less than or equal to it.</p>
<h1 class="unnumbered" id="factoring-basic-claims-continued">Factoring
basic claims continued</h1>
<p><span><strong>Claim</strong></span>: Every nonzero integer is a
factor of itself and every nonzero integer divides its square.</p>
<h1 class="unnumbered" id="factoring-even-odd">Factoring even odd</h1>
<p><span><strong>Definition</strong></span>: an integer <span
class="math inline">\(n\)</span> is <span><strong>even</strong></span>
means that there is an integer <span class="math inline">\(a\)</span>
such that <span class="math inline">\(n = 2a\)</span>; an integer <span
class="math inline">\(n\)</span> is <span><strong>odd</strong></span>
means that there is an integer <span class="math inline">\(a\)</span>
such that <span class="math inline">\(n = 2a+1\)</span>. Equivalently,
an integer <span class="math inline">\(n\)</span> is
<span><strong>even</strong></span> means <span class="math inline">\(n
~\textbf{ mod }~2 = 0\)</span>; an integer <span
class="math inline">\(n\)</span> is <span><strong>odd</strong></span>
means <span class="math inline">\(n ~\textbf{ mod }~2 = 1\)</span>.
Also, an integer is even if and only if it is not odd.</p>
<h1 class="unnumbered" id="prime-number-definition">Prime number
definition</h1>
<p><span><strong>Definition</strong></span>: An integer <span
class="math inline">\(p\)</span> greater than <span
class="math inline">\(1\)</span> is called
<span><strong>prime</strong></span> means the only positive factors of
<span class="math inline">\(p\)</span> are <span
class="math inline">\(1\)</span> and <span
class="math inline">\(p\)</span>. A positive integer that is greater
than <span class="math inline">\(1\)</span> and is not prime is called
composite.</p>
<h1 class="unnumbered" id="primes-basic-claims">Primes basic claims</h1>
<p><span><em>Extra examples</em></span>: Use the definition to prove
that <span class="math inline">\(1\)</span> is not prime, <span
class="math inline">\(2\)</span> is prime, <span
class="math inline">\(3\)</span> is prime, <span
class="math inline">\(4\)</span> is not prime, <span
class="math inline">\(5\)</span> is prime, <span
class="math inline">\(6\)</span> is not prime, and <span
class="math inline">\(7\)</span> is prime.</p>
<p><span><strong>True or False</strong></span>: The statement “There are
three consecutive positive integers that are prime."</p>
<p><span><em>Hint</em></span>: These numbers would be of the form <span
class="math inline">\(p, p+1, p+2\)</span> (where <span
class="math inline">\(p\)</span> is a positive integer).</p>
<p><span><strong>Proof</strong></span>: We need to show <u></u></p>
<p><span><strong>True or False</strong></span>: The statement “There are
three consecutive odd positive integers that are prime."</p>
<p><span><em>Hint</em></span>: These numbers would be of the form <span
class="math inline">\(p, p+2, p+4\)</span> (where <span
class="math inline">\(p\)</span> is an odd positive integer).</p>
<p><span><strong>Proof</strong></span>: We need to show <u></u></p>
<h1 class="unnumbered" id="rna-rnalen-basecount-definitions-2">Rna
rnalen basecount definitions</h1>
<p><span><em>Recall the definitions</em></span>: The set of RNA strands
<span class="math inline">\(S\)</span> is defined (recursively) by:
<span class="math display">\[\begin{array}{ll}
\textrm{Basis Step: } &amp; \texttt{A}\in S, \texttt{C}\in S,
\texttt{U}\in S, \texttt{G}\in S \\
\textrm{Recursive Step: } &amp; \textrm{If } s \in S\textrm{ and }b \in
B \textrm{, then }sb \in S
\end{array}\]</span> where <span class="math inline">\(sb\)</span> is
string concatenation.</p>
<p>The function <em>rnalen</em> that computes the length of RNA strands
in <span class="math inline">\(S\)</span> is defined recursively by:
<span class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{rnalen} : S &amp; \to \mathbb{Z}^+ \\
\textrm{Basis Step:} &amp; \textrm{If } b \in B\textrm{ then } &amp;
\textit{rnalen}(b) &amp; = 1 \\
\textrm{Recursive Step:} &amp; \textrm{If } s \in S\textrm{ and }b \in
B\textrm{, then  } &amp; \textit{rnalen}(sb) &amp; = 1 +
\textit{rnalen}(s)
\end{array}\]</span></p>
<p>The function <em>basecount</em> that computes the number of a given
base <span class="math inline">\(b\)</span> appearing in a RNA strand
<span class="math inline">\(s\)</span> is defined recursively by: <span
class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{basecount} : S \times B &amp; \to \mathbb{N} \\
\textrm{Basis Step:} &amp;  \textrm{If } b_1 \in B, b_2 \in B &amp;
\textit{basecount}(~(b_1, b_2)~) &amp; =
        \begin{cases}
            1 &amp; \textrm{when } b_1 = b_2 \\
            0 &amp; \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} &amp; \textrm{If } s \in S, b_1 \in B, b_2 \in
B &amp;\textit{basecount}(~(s b_1, b_2)~) &amp; =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) &amp; \textrm{when } b_1
= b_2 \\
            \textit{basecount}(~(s, b_2)~) &amp; \textrm{when } b_1 \neq
b_2 \\
        \end{cases}
\end{array}\]</span></p>
<h1 class="unnumbered"
id="alternating-quantifiers-proofs-rna-examples">Alternating quantifiers
proofs rna examples</h1>
<p>Which proof strategies could be used to prove each of the following
statements?</p>
<p><span><em>Hint: first translate the statements to English and
identify the main logical structure.</em></span></p>
<p><span class="math inline">\(\forall s \in S~(~rnalen(s) &gt;
0~)\)</span></p>
<p><span class="math inline">\(\forall b \in B~\exists s \in
S~(~basecount(~(s,b)~)~ &gt; 0~)\)</span></p>
<p><span class="math inline">\(\forall s \in S ~\exists b\in B
~(~basecount(~(s,b)~) &gt; 0~)\)</span></p>
<p><span class="math inline">\(\exists s \in S \, (\textit{rnalen(s)} =
\textit{basecount}(~(s, \texttt{A})~)\)</span></p>
<p><span class="math inline">\(\forall s \in S \, (\textit{rnalen(s)}
\geq \textit{basecount}(~(s, \texttt{A})~))\)</span></p>
<h1 class="unnumbered"
id="structural-induction-motivating-example-rna">Structural induction
motivating example rna</h1>
<p><span><strong>Claim</strong></span> <span
class="math inline">\(\forall s \in S ~(~rnalen(s) &gt; 0~)\)</span></p>
<p><span><strong>Proof</strong></span>: Let <span
class="math inline">\(s\)</span> be an arbitrary RNA strand. By the
recursive definition of <span class="math inline">\(S\)</span>, either
<span class="math inline">\(s \in B\)</span> or there is some strand
<span class="math inline">\(s_0\)</span> and some base <span
class="math inline">\(b\)</span> such that <span class="math inline">\(s
= s_0 b\)</span>. We will show that the inequality holds for both
cases.</p>
<p><span><span class="math inline">\(\phantom{Basis}\)</span></span>
<span><strong>Case</strong></span>: Assume <span class="math inline">\(s
\in B\)</span>. We need to show <span class="math inline">\(rnalen(s)
&gt; 0\)</span>. By the basis step in the definition of <span
class="math inline">\(rnalen\)</span>, <span
class="math display">\[rnalen(s) = 1\]</span> which is greater than
<span class="math inline">\(0\)</span>, as required.</p>
<p><span><span class="math inline">\(\phantom{Recursive}\)</span></span>
<span><strong>Case</strong></span>: Assume there is some strand <span
class="math inline">\(s_0\)</span> and some base <span
class="math inline">\(b\)</span> such that <span class="math inline">\(s
= s_0 b\)</span>. We will show <span><em>(the stronger
claim)</em></span> that <span class="math display">\[\forall u \in S
~\forall b \in B ~( ~\textit{rnalen}(u) &gt;0  \to
    \textit{rnalen}(ub) &gt;0 ~)\]</span> Consider an arbitrary RNA
strand <span class="math inline">\(u\)</span> and an arbitrary base
<span class="math inline">\(b\)</span>, and assume towards a direct
proof,<span class="math inline">\(~~{\phantom{ this is the induction
hypothesis}}~~\)</span> that <span class="math display">\[rnalen(u) &gt;
0\]</span> We need to show that <span class="math inline">\(rnalen(ub)
&gt; 0\)</span>. <span class="math display">\[rnalen(ub) = 1 + rnalen
(u) &gt; 1 + 0 = 1 &gt; 0\]</span> as required.</p>
<h1 class="unnumbered" id="proof-strategies-structural-induction">Proof
strategies structural induction</h1>
<h1 class="unnumbered"
id="structural-induction-example-rnalen-basecount">Structural induction
example rnalen basecount</h1>
<p><span><strong>Claim</strong></span> <span
class="math inline">\(\forall s \in S \, (\textit{rnalen(s)} \geq
\textit{basecount}(~(s, \texttt{A})~))\)</span>:</p>
<p><span><strong>Proof</strong></span>: We proceed by structural
induction on the recursively defined set <span
class="math inline">\(S\)</span>.</p>
<p><span><strong>Basis Case</strong></span>: We need to prove that the
inequality holds for each element in the basis step of the recursive
definition of <span class="math inline">\(S\)</span>. Need to show <span
class="math display">\[\begin{aligned}
          &amp;(~ rnalen(\texttt{A}) \geq basecount(~(\texttt{A},
\texttt{A})~)~) \land (~ rnalen(\texttt{C}) \geq basecount(~(\texttt{C},
\texttt{A})~)~) \\
    \land &amp; (~ rnalen(\texttt{U}) \geq basecount(~(\texttt{U},
\texttt{A})~)~) \land (~ rnalen(\texttt{G}) \geq basecount(~(\texttt{G},
\texttt{A})~)~)
\end{aligned}\]</span> We calculate, using the definitions of <span
class="math inline">\(rnalen\)</span> and <span
class="math inline">\(basecount\)</span>:</p>
<p><span><strong>Recursive Case</strong></span>: We will prove that
<span class="math display">\[\forall u \in S ~\forall b \in B ~(
~rnalen(u) \geq basecount(~(u, \texttt{A})~) \to
    rnalen(ub) \geq basecount(~(ub, \texttt{A})~)\]</span></p>
<p>Consider arbitrary RNA strand <span class="math inline">\(u\)</span>
and arbitrary base <span class="math inline">\(b\)</span>. Assume, as
the <span><strong>induction hypothesis</strong></span>, that <span
class="math inline">\(rnalen(u) \geq
basecount(~(u,\texttt{A})~)\)</span>. We need to show that <span
class="math inline">\(rnalen(ub) \geq basecount(~(ub,
\texttt{A})~)\)</span>.</p>
<p>Using the recursive step in the definition of the function <span
class="math inline">\(rnalen\)</span>: <span
class="math display">\[rnalen(ub) = 1 + rnalen(u)\]</span> The recursive
step in the definition of the function <span
class="math inline">\(basecount\)</span> has two cases. We notice that
<span class="math inline">\(b = \texttt{A}\lor b \neq
\texttt{A}\)</span> and we proceed by cases.</p>
<p><span><em>Case i.</em></span> Assume <span class="math inline">\(b =
\texttt{A}\)</span>.</p>
<p>Using the first case in the recursive step in the definition of the
function <span class="math inline">\(basecount\)</span>: <span
class="math display">\[basecount(~(ub, \texttt{A})~) = 1 +
basecount(~(u,\texttt{A})~)\]</span> By the <span><strong>induction
hypothesis</strong></span>, we know that <span
class="math inline">\(basecount(~(u,\texttt{A})~) \leq
rnalen(u)\)</span> so: <span class="math display">\[basecount(~(ub,
\texttt{A})~) = 1 + basecount(~(u,\texttt{A})~) \leq 1 + rnalen(u) =
rnalen (ub)\]</span> and, thus, <span
class="math inline">\(basecount(~(ub,\texttt{A})~) \leq
rnalen(ub)\)</span>, as required.</p>
<p><span><em>Case ii.</em></span> Assume <span class="math inline">\(b
\neq \texttt{A}\)</span>.</p>
<p>Using the second case in the recursive step in the definition of the
function <span class="math inline">\(basecount\)</span>: <span
class="math display">\[basecount(~(ub, \texttt{A})~) =
basecount(~(u,\texttt{A})~)\]</span> By the <span><strong>induction
hypothesis</strong></span>, we know that <span
class="math inline">\(basecount(~(u,\texttt{A})~) \leq
rnalen(u)\)</span> so: <span class="math display">\[basecount(~(ub,
\texttt{A})~) = basecount(~(u,\texttt{A})~) \leq rnalen(u) &lt; 1 +
rnalen(u) = rnalen (ub)\]</span> and, thus, <span
class="math inline">\(basecount(~(ub,\texttt{A})~) \leq
rnalen(ub)\)</span>, as required.</p>
<h1 class="unnumbered" id="proofs-signposting-kinds-of-claims">Proofs
signposting kinds of claims</h1>
<p>To organize our proofs, it’s useful to highlight which claims are
most important for our overall goals. We use some terminology to
describe different roles statements can have.</p>
<p><span><strong>Theorem</strong></span>: Statement that can be shown to
be true, usually an important one.</p>
<p>Less important theorems can be called
<span><strong>proposition</strong></span>,
<span><strong>fact</strong></span>,
<span><strong>result</strong></span>,
<span><strong>claim</strong></span>.</p>
<p><span><strong>Lemma</strong></span>: A less important theorem that is
useful in proving a theorem.</p>
<p><span><strong>Corollary</strong></span>: A theorem that can be proved
directly after another one has been proved, without needing a lot of
extra work.</p>
<p><span><strong>Invariant</strong></span>: A theorem that describes a
property that is true about an algorithm or system no matter what inputs
are used.</p>
<h1 class="unnumbered"
id="structural-induction-example-robot-grid">Structural induction
example robot grid</h1>
<div class="center">
<p><img src="../../resources/images/robot-grid.png" style="width:3in"
alt="image" /></p>
</div>
<p><span><strong>Theorem</strong></span>: A robot on an infinite
2-dimensional integer grid starts at <span
class="math inline">\((0,0)\)</span> and at each step moves to
diagonally adjacent grid point. This robot can / cannot
<span>(<span><em>circle one</em></span>)</span> reach <span
class="math inline">\((1,0)\)</span>.</p>
<p><span><strong>Definition</strong></span> The set of positions the
robot can visit <span class="math inline">\(Pos\)</span> is defined by:
<span class="math display">\[\begin{array}{ll}
    \textrm{Basis Step: } &amp; (0,0) \in Pos \\
    \textrm{Recursive Step: } &amp; \textrm{If } (x,y) \in Pos \textrm{,
then } \\
    &amp;\phantom{(x+1, y+1), (x+1, y-1), (x-1, y-1), (x-1, y+1)}
\textrm{ are also in } Pos
\end{array}\]</span></p>
<p><span><em>Example elements of <span
class="math inline">\(Pos\)</span> are</em></span>:</p>
<p><span><strong>Lemma</strong></span>: <span
class="math inline">\(\forall (x,y) \in Pos~~( x+y \textrm{ is an even
integer}~)\)</span></p>
<p><span><em>Why are we calling this a lemma?</em></span></p>
<p>Proof of theorem using lemma: To show is <span
class="math inline">\((1,0) \notin Pos\)</span>. Rewriting the lemma to
explicitly restrict the domain of the universal, we have <span
class="math inline">\(\forall (x,y) ~(~ (x,y) \in Pos~~  \to ~~(x+y
\textrm{ is an even integer})~)\)</span>. Since the universal is true,
<span class="math inline">\((~ (1,0) \in Pos~~ \to ~~(1+0 \textrm{ is an
even integer})~)\)</span> is a true statement. Evaluating the conclusion
of this conditional statement: By definition of long division, since
<span class="math inline">\(1 = 0 \cdot 2 + 1\)</span> (where <span
class="math inline">\(0 \in \mathbb{Z}\)</span> and <span
class="math inline">\(1 \in \mathbb{Z}\)</span> and <span
class="math inline">\(0 \leq 1 &lt; 2\)</span> mean that <span
class="math inline">\(0\)</span> is the quotient and <span
class="math inline">\(1\)</span> is the remainder), <span
class="math inline">\(1 ~\textrm{\bf mod}~ 2 = 1\)</span> which is not
<span class="math inline">\(0\)</span> so the conclusion is false. A
true conditional with a false conclusion must have a false hypothesis:
<span class="math inline">\((1,0) \notin Pos\)</span>, QED. <span
class="math inline">\(\square\)</span></p>
<p>Proof of lemma by structural induction:</p>
<p><span><strong>Basis Step</strong></span>:</p>
<p><span><strong>Recursive Step</strong></span>: Consider arbitrary
<span class="math inline">\((x,y) \in Pos\)</span>. To show is: <span
class="math display">\[(x+y \text{ is an even integer}) \to (\text{sum
of coordinates of next position is even integer})\]</span> Assume
<span><strong>as the induction hypothesis, IH</strong></span> that:</p>
<h1 class="unnumbered"
id="structural-induction-example-sum-of-powers">Structural induction
example sum of powers</h1>
<p>The set <span class="math inline">\(\mathbb{N}\)</span> is
recursively defined. Therefore, the function <span
class="math inline">\(sumPow: \mathbb{N} \to \mathbb{N}\)</span> which
computes, for input <span class="math inline">\(i\)</span>, the sum of
the nonnegative powers of <span class="math inline">\(2\)</span> up to
and including exponent <span class="math inline">\(i\)</span> is defined
recursively by</p>
<p><span class="math display">\[\begin{aligned}
{2}
    \text{Basis step:  } \qquad &amp; sumPow(0) = 1 &amp;\\
    \text{Recursive step:  } &amp; \text{If } x \in \mathbb{N} \text{,
then } &amp;sumPow(x+1) = sumPow(x) + 2^{x+1}
\end{aligned}\]</span></p>
<p><span class="math inline">\(sumPow(0) =\)</span></p>
<p><span class="math inline">\(sumPow(1) =\)</span></p>
<p><span class="math inline">\(sumPow(2) =\)</span></p>
<p>Fill in the blanks in the following proof of <span
class="math display">\[\forall n \in \mathbb{N}~(sumPow(n) = 2^{n+1} -
1)\]</span></p>
<p><span><strong>Proof</strong></span>: Since <span
class="math inline">\(\mathbb{N}\)</span> is recursively defined, we
proceed by <u></u>.</p>
<p><span><strong>Basis case</strong></span>: We need to show that
<u></u>. Evaluating each side: <span class="math inline">\(LHS =
sumPow(0) = 1\)</span> by the basis case in the recursive definition of
<span class="math inline">\(sumPow\)</span>; <span
class="math inline">\(RHS = 2^{0+1} - 1 = 2^1 - 1 = 2-1 = 1\)</span>.
Since <span class="math inline">\(1=1\)</span>, the equality holds.</p>
<p><span><strong>Recursive case</strong></span>: Consider arbitrary
natural number <span class="math inline">\(n\)</span> and assume, as the
<u></u> that <span class="math inline">\(sumPow(n) = 2^{n+1} -
1\)</span>. We need to show that <u></u>. Evaluating each side: <span
class="math display">\[LHS = sumPow(n+1) \overset{\text{rec def}}{=}
sumPow(n)  + 2^{n+1}\overset{\text{IH}}{=} (2^{n+1} - 1) +
2^{n+1}.\]</span> <span class="math display">\[RHS = 2^{(n+1)+1}- 1
\overset{\text{exponent rules}}{=} 2 \cdot 2^{n+1} -1  = \left(2^{n+1} +
2^{n+1} \right) - 1
\overset{\text{regrouping}}{=}  (2^{n+1} - 1) + 2^{n+1}\]</span> Thus,
<span class="math inline">\(LHS = RHS\)</span>. The structural induction
is complete and we have proved the universal generalization. <span
class="math inline">\(\square\)</span></p>
<h1 class="unnumbered" id="proof-strategy-mathematical-induction">Proof
strategy mathematical induction</h1>
<h1 class="unnumbered"
id="tautology-contradiction-contingency-examples">Tautology
contradiction contingency examples</h1>
<p>Label each of the following as a tautology, contradiction, or
contingency.</p>
<p><span class="math inline">\(p \land p\)</span></p>
<p><span class="math inline">\(p \oplus p\)</span></p>
<p><span class="math inline">\(p \lor p\)</span></p>
<p><span class="math inline">\(p \lor \lnot p\)</span></p>
<p><span class="math inline">\(p \land \lnot p\)</span></p>
<h1 class="unnumbered" id="why-represent-numbers">Why represent
numbers</h1>
<p>Modeling uses data-types that are encoded in a computer. The details
of the encoding impact the efficiency of algorithms we use to understand
the systems we are modeling and the impacts of these algorithms on the
people using the systems. Case study: how to encode numbers?</p>
<h1 class="unnumbered" id="fixed-width-definition">Fixed width
definition</h1>
<p><span><strong>Definition</strong></span> For <span
class="math inline">\(b\)</span> an integer greater than <span
class="math inline">\(1\)</span>, <span class="math inline">\(w\)</span>
a positive integer, and <span class="math inline">\(n\)</span> a
nonnegative integer <span
class="math inline">\(\underline{\phantom{\hspace{1in}}}\)</span>,   the
<span><strong>base <span class="math inline">\(b\)</span> fixed-width
<span class="math inline">\(w\)</span> expansion of <span
class="math inline">\(n\)</span></strong></span> is <span
class="math display">\[(a_{w-1} \cdots a_1 a_0)_{b,w}\]</span> where
<span class="math inline">\(a_0, a_1, \ldots, a_{w-1}\)</span> are
nonnegative integers less than <span class="math inline">\(b\)</span>
and <span class="math display">\[n =  \sum_{i=0}^{w-1} a_{i}
b^{i}\]</span></p>
<h1 class="unnumbered" id="fixed-width-example">Fixed width example</h1>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Decimal</td>
<td style="text-align: center;">Binary</td>
<td style="text-align: center;">Binary fixed-width <span
class="math inline">\(10\)</span></td>
<td style="text-align: center;">Binary fixed-width <span
class="math inline">\(7\)</span></td>
<td style="text-align: center;">Binary fixed-width <span
class="math inline">\(4\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(b=10\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(b=2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(b=2\)</span>, <span class="math inline">\(w
=  10\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(b=2\)</span>, <span class="math inline">\(w
=  7\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(b=2\)</span>, <span class="math inline">\(w
=  4\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\((20)_{10}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<h1 class="unnumbered" id="fixed-width-fractional-definition">Fixed
width fractional definition</h1>
<p><span><strong>Definition</strong></span> For <span
class="math inline">\(b\)</span> an integer greater than <span
class="math inline">\(1\)</span>, <span class="math inline">\(w\)</span>
a positive integer, <span class="math inline">\(w&#39;\)</span> a
positive integer, and <span class="math inline">\(x\)</span> a real
number the <span><strong>base <span class="math inline">\(b\)</span>
fixed-width expansion of <span class="math inline">\(x\)</span> with
integer part width <span class="math inline">\(w\)</span> and fractional
part width <span class="math inline">\(w&#39;\)</span></strong></span>
is <span class="math inline">\((a_{w-1} \cdots a_1 a_0 .  c_{1} \cdots
c_{w&#39;})_{b,w,w&#39;}\)</span> where <span class="math inline">\(a_0,
a_1, \ldots, a_{w-1}, c_1, \ldots, c_{w&#39;}\)</span> are nonnegative
integers less than <span class="math inline">\(b\)</span> and <span
class="math display">\[x \geq \sum_{i=0}^{w-1} a_{i} b^{i} +
\sum_{j=1}^{w&#39;}  c_{j} b^{-j} \hfill
\textrm{\qquad and \qquad}
\hfill x &lt; \sum_{i=0}^{w-1} a_{i} b^{i} + \sum_{j=1}^{w&#39;} c_{j}
b^{-j} + b^{-w&#39;}\]</span></p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(3.75\)</span> in fixed-width binary,</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">integer part width <span
class="math inline">\(2\)</span>,</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">fractional part width <span
class="math inline">\(8\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(0.1\)</span>
in fixed-width binary,</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">integer part width <span
class="math inline">\(2\)</span>,</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">fractional part width <span
class="math inline">\(8\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><img src="../../resources/images/ArithmeticDemo.png"
style="width:2in" alt="image" /></p>
<p>Note: Java uses floating point, not fixed width representation, but
similar rounding errors appear in both.</p>
<h1 class="unnumbered" id="negative-int-expansions">Negative int
expansions</h1>
<p><span><strong>Representing negative integers in
binary</strong></span>: Fix a positive integer width for the
representation <span class="math inline">\(w\)</span>, <span
class="math inline">\(w &gt;1\)</span>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: left;">To represent a positive integer <span
class="math inline">\(n\)</span></th>
<th style="text-align: left;">To represent a negative integer <span
class="math inline">\(-n\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">&amp; <span class="math inline">\([
0a_{w-2} \cdots a_0]_{s,w}\)</span>, where <span class="math inline">\(n
=  (a_{w-2} \cdots a_0)_{2,w-1}\)</span>&amp; <span
class="math inline">\([1a_{w-2} \cdots a_0]_{s,w}\)</span> , where <span
class="math inline">\(n =  (a_{w-2} \cdots a_0)_{2,w-1}\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h1 class="unnumbered" id="calculating-2s-complement">Calculating 2s
complement</h1>
<p>For positive integer <span class="math inline">\(n\)</span>, to
represent <span class="math inline">\(-n\)</span> in <span
class="math inline">\(2\)</span>s complement with width <span
class="math inline">\(w\)</span>,</p>
<ul>
<li><p>Calculate <span class="math inline">\(2^{w-1} - n\)</span>,
convert result to binary fixed-width <span
class="math inline">\(w-1\)</span>, pad with leading <span
class="math inline">\(1\)</span>, or</p></li>
<li><p>Express <span class="math inline">\(-n\)</span> as a sum of
powers of <span class="math inline">\(2\)</span>, where the leftmost
<span class="math inline">\(2^{w-1}\)</span> is negative weight,
or</p></li>
<li><p>Convert <span class="math inline">\(n\)</span> to binary
fixed-width <span class="math inline">\(w\)</span>, flip bits, add 1
(ignore overflow)</p></li>
</ul>
<p><span><em>Challenge: use definitions to explain why each of these
approaches works.</em></span></p>
<h1 class="unnumbered" id="representing-zero">Representing zero</h1>
<p><span><strong>Representing <span
class="math inline">\(0\)</span></strong></span>:</p>
<p>So far, we have representations for positive and negative integers.
What about <span class="math inline">\(0\)</span>?</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: left;">To represent a
<span><strong>non-negative</strong></span> integer <span
class="math inline">\(n\)</span></th>
<th style="text-align: left;">To represent a
<span><strong>non-positive</strong></span> integer <span
class="math inline">\(-n\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">&amp; <span class="math inline">\([
0a_{w-2} \cdots a_0]_{s,w}\)</span>, where <span class="math inline">\(n
=  (a_{w-2} \cdots a_0)_{2,w-1}\)</span>&amp; <span
class="math inline">\([1a_{w-2} \cdots a_0]_{s,w}\)</span> , where <span
class="math inline">\(n =  (a_{w-2} \cdots a_0)_{2,w-1}\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</body>
</html>
