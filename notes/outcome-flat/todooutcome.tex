\documentclass[12pt, oneside]{article}

\usepackage[letterpaper, scale=0.89, centering]{geometry}
\usepackage{fancyhdr}
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\rfoot{\href{https://creativecommons.org/licenses/by-nc-sa/2.0/}{CC BY-NC-SA 2.0} Version \today~(\thepage)}

\usepackage{amssymb,amsmath,pifont,amsfonts,comment,enumerate,enumitem}
\usepackage{currfile,xstring,hyperref,tabularx,graphicx,wasysym}
\usepackage[labelformat=empty]{caption}
\usepackage{xcolor}
\usepackage{multicol,multirow,array,listings,tabularx,lastpage,textcomp,booktabs}

\lstnewenvironment{algorithm}[1][] {   
    \lstset{ mathescape=true,
        frame=tB,
        numbers=left, 
        numberstyle=\tiny,
        basicstyle=\rmfamily\scriptsize, 
        keywordstyle=\color{black}\bfseries,
        keywords={,procedure, div, for, to, input, output, return, datatype, function, in, if, else, foreach, while, begin, end, }
        numbers=left,
        xleftmargin=.04\textwidth,
        #1
    }
}
{}
\lstnewenvironment{java}[1][]
{   
    \lstset{
        language=java,
        mathescape=true,
        frame=tB,
        numbers=left, 
        numberstyle=\tiny,
        basicstyle=\ttfamily\scriptsize, 
        keywordstyle=\color{black}\bfseries,
        keywords={, int, double, for, return, if, else, while, }
        numbers=left,
        xleftmargin=.04\textwidth,
        #1
    }
}
{}

\newcommand\abs[1]{\lvert~#1~\rvert}
\newcommand{\st}{\mid}

\newcommand{\A}[0]{\texttt{A}}
\newcommand{\C}[0]{\texttt{C}}
\newcommand{\G}[0]{\texttt{G}}
\newcommand{\U}[0]{\texttt{U}}

\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

 
\begin{document}
\begin{flushright}
    \StrBefore{\currfilename}{.}
\end{flushright} \section*{Binary relation definition}


{\bf Definition}: When $A$ and $B$ are sets, we say any subset of $A \times B$ is a {\bf binary relation}. 
A relation $R$ can also be represented as

\begin{itemize}
\item A function $f_{TF} : A \times B \to \{T, F\}$
where, for $a \in A$ and $b \in B$, $f_{TF}(~(a,b)~) = 
\begin{cases} 
    T \qquad&\text{when } (a,b) \in R \\
    F \qquad&\text{when } (a,b) \notin R
\end{cases}$
\item A function $f_{\mathcal{P}} : A   \to \mathcal{P}(B)$ where, for $a \in A$, 
$f_{\mathcal{P}}( a ) = \{ b \in B ~|~ (a,b) \in R \}$
\end{itemize}

When $A$ is a set, we say any subset of $A \times A$ is a (binary) {\bf relation} on $A$.

 \vfill
\section*{Binary relation examples}


{\it Example}: For $A = \mathcal{P}(\mathbb{R})$, we can define the relation $EQ_{\mathbb{R}}$ on $A$ as 
\[
\{ (X_1, X_2 ) \in\mathcal{P}(\mathbb{R})  \times \mathcal{P}(\mathbb{R}) ~|~ |X_1| = |X_2| \}
\]

\vfill

{\it Example}: Let $R_{(\textbf{mod } n)}$ be the set of all pairs of integers $(a, b)$ such that $(a \textbf{ mod } n = b \textbf{ mod } n)$.
Then $a$ is {\bf congruent to} $b$ \textbf{mod} $n$ means $(a, b) \in R_{(\textbf{mod } n)}$. A common notation is to write this as $a \equiv b (\textbf{mod } n)$.


$R_{(\textbf{mod } n)}$ is a relation on the set $\underline{\phantom{\mathbb{Z}}\hspace{20em}}$


Some example elements of $R_{(\textbf{mod } 4)}$ are: 

\vfill \vfill
\section*{Reflexive relation definition}


A relation $R$ on a set $A$ is called {\bf reflexive} 
means $(a, a) \in R$ for every element $a \in A$. 
 \vfill
\section*{Reflexive relation informally}


{\it Informally}, every element is related to itself.

{\it Graphically}, there are self-loops (edge from a node back to itself) at 
every node. \vfill
\section*{Symmetric relation definition}


A relation $R$ on a set $A$ is called {\bf symmetric} means 
$(b, a) \in R$ whenever $(a, b) \in R$, for all $a, b \in A$. 
 \vfill
\section*{Symmetric relation informally}


{\it Informally}, order doesn't matter for this relation.

{\it Graphically}, every edge has a paired ``backwards'' edge so we might
as well drop the arrows and think of edges as undirected. \vfill
\section*{Transitive relation definition}


A relation $R$ on a set $A$ is called {\bf transitive} means 
whenever $(a, b) \in R$ and $(b, c) \in R$, then $(a, c) \in R$, for all $a, b, c \in A$.
 \vfill
\section*{Transitive relation informally}


{\it Informally}, chains of relations collapse.

{\it Graphically}, there's a shortcut between any endpoints of a chain of 
edges. \vfill
\section*{Antisymmetric relation definition}


A relation $R$ on a set $A$ is called {\bf antisymmetric} means 
$\forall a \in A ~\forall b \in A~\left(~\left( ~(a,b) \in R \land (b,a) \in R ~\right) \to a=b~\right)$
 \vfill
\section*{Antisymmetric relation informally}


{\it Informally}, the relation has directionality.

{\it Graphically}, can organize the nodes of the graph so that 
all non-self loop edges go up. \vfill
\section*{Binary relation properties examples}



When the domain is $\{ a,b,c,d,e,f,g,h\}$ define a relation that is {\bf not reflexive} and 
is {\bf not symmetric} and is {\bf not transitive}.

\vfill

When the domain is $\{ a,b,c,d,e,f,g,h\}$ define a relation that is {\bf not reflexive} but 
is {\bf symmetric} and is {\bf transitive}.

\vfill

When the domain is $\{ a,b,c,d,e,f,g,h\}$ define a relation that is {\bf symmetric} and
is {\bf antisymmetric}.

\vfill

Is the relation $EQ_{\mathbb{R}}$ reflexive? symmetric? transitive? antisymmetric?

\vfill

Is the relation $R_{(\textbf{mod } 4)}$ reflexive? symmetric? transitive? antisymmetric?

\vfill
%
 \vfill
\section*{Cardinality caution}


{\it Caution}: we use 
familiar symbols to define cardinality, like
$| \phantom{\cdots} | \leq | \phantom{\cdots} |$
and 
$| \phantom{\cdots} | \geq | \phantom{\cdots} |$
and 
$| \phantom{\cdots} | = | \phantom{\cdots} |$, 
but the meaning of these symbols depends on context.
We've seen that vertical lines can mean absolute
value (for real numbers), divisibility (for integers), 
and now sizes (for sets). 

Now we see that $\leq$ and $\geq$ can mean comparing
numbers or comparing sizes of sets. When the sets being 
compared are finite, the definitions 
of $|A| \leq |B|$ agree. 

But, properties of numbers cannot be assumed when comparing
cardinalities of infinite sets.

In a nutshell: cardinality of sets is defined via functions.
This definition agrees with the usual notion of ``size'' for 
finite sets. \vfill
\section*{Cantor schroder bernstein theorem}


{\bf Cantor-Schroder-Bernstein Theorem}: For all nonempty sets,
\[
|A| = |B| \qquad\text{if and only if} \qquad (|A| \leq |B| ~\text{and}~ |B| \leq |A|)
\qquad\text{if and only if} \qquad (|A| \geq |B| ~\text{and}~ |B| \geq |A|)
\]

To prove $|A| = |B|$,  we can do any {\bf one} of the following

\begin{itemize}\setlength{\itemsep}{-5pt}
\item Prove there exists  a bijection $f:  A \to B$;
\item Prove there exists a  bijection  $f: B  \to  A$;
\item Prove there exists two functions $f_1: A \to B$, $f_2: B \to  A$ where each of $f_1, f_2$ is one-to-one.
\item Prove there exists two functions $f_1: A \to B$, $f_2: B \to  A$ where each of $f_1, f_2$ is onto.
\end{itemize} \vfill
\section*{Countably infinite definition}


{\bf Definition}: A set $A$ is {\bf countably infinite} means it is the 
same size as $\mathbb{N}$.

 \vfill
\section*{Countably infinite examples sets of numbers}


{\bf Natural numbers} $\mathbb{N}$ \hfill {\it List}:  $0~~1~~2~~3~~4~~5~~6~~7~~8~~9~~10 \ldots$

$identity: \mathbb{N} \to \mathbb{N}$ with $identity(n) = n$

{\it Claim}: $identity$ is a bijection. {\it Proof}: Ex. \hfill {\bf Corollary}: $ | \mathbb{N} | = |\mathbb{N}|~$

{\bf Positive integers} $\mathbb{Z}^+$ \hfill {\it List}:  $1~~2~~3~~4~~5~~6~~7~~8~~9~~10~~11\ldots$

$positives: \mathbb{N} \to \mathbb{Z}^+$ with $positives(n) = n+1$

{\it Claim}: $positives$ is a bijection.  {\it Proof}: Ex.\hfill {\bf Corollary}: $ | \mathbb{N} | = |\mathbb{Z}^+|$

{\bf Negative integers $\mathbb{Z}^-$}\hfill  {\it List}: $-1$~$-2$~$-3$~$-4$~$-5$~$-6$~$-7$~$-8$~$-9$~$-10$~$-11$\ldots

$negatives: \mathbb{N} \to \mathbb{Z}^-$ with $negatives(n) = -n-1$

{\it Claim}: $negatives$ is a bijection. \hfill {\bf Corollary}: $ | \mathbb{N} | = |\mathbb{Z}^-|$

{\it Proof}: We need to show it is a well-defined function that is one-to-one and onto.

\begin{itemize}
\item Well-defined? 

Consider an arbitrary element of the domain, $n \in \mathbb{N}$. We need to show it maps to exactly one element of $\mathbb{Z}^-$.

\vfill

\item One-to-one?


Consider arbitrary elements of the domain $a, b \in \mathbb{N}$. We need to show that 
$$\left(~negatives(a) = negatives(b) ~\right) \to (a=b)$$

\vfill

\item Onto?

Consider arbitrary element of the codomain $b \in \mathbb{Z}^-$. We need witness in $\mathbb{N}$ that maps to $b$.

\vfill
\end{itemize}

{\bf Integers} $\mathbb{Z}$ \hfill {\it List}:  $0~-1~~1~-2~~2~-3~~3~-4~~4~-5~~5$\ldots

$f: \mathbb{Z} \to \mathbb{N}$ with $f(x) = \begin{cases}2x &\text{if $x \geq 0$} \\-2x-1 &\text{if $x < 0$} \end{cases}$

{\it Claim}: $f$ is a bijection.  {\it Proof}: Ex.\hfill {\bf Corollary}: $ | \mathbb{Z} | = |\mathbb{N}|$
\newpage


 \vfill
\section*{Countably infinite examples other sets}


{\bf More examples of countably infinite sets}

{\bf Claim}: $S$ is countably infinite

{\it Similarly: The set of all strings over a specific alphabet is countably infinite.}
\begin{center}
Bijection using alphabetical-ish ordering
(first order by length, then alphabetically among strings of same length) 
of strands
\end{center}

\vspace{50pt}


{\bf Claim}: $L$ is countably infinite

\begin{multicols}{2}
\begin{align*}
    &list: \mathbb{N} \to L \\
    &list(n) = (n, []) \\
    &
\end{align*}

\begin{align*}
    &toNum: L \to \mathbb{N} \\
    &toNum([]) = 0 \\
    &toNum( ~(n,l)~) = 2^n 3^{toNum}(l) \qquad \text{for $n \in \mathbb{N}$, $l \in L$}
\end{align*}
\end{multicols}
\vspace{30pt}

{\bf Claim}: $|\mathbb{Z}^+| = |\mathbb{Q}|$ 

One-to-one function from $\mathbb{Z}^+$ to $\mathbb{Q}$
is $f_1: \mathbb{Z} \to \mathbb{Q}$ with $f_1(n) = n$ for all 
$n \in \mathbb{N}$.

\vspace{30pt}


\begin{align*}
    &f_2: \mathbb{Q} \to \mathbb{Z} \times \mathbb{Z} \\
    &f_2(x) = \begin{cases}
        (0,1) & \text{if $x = 0$} \\
        (p,q) & \text{if $x = \frac{p}{q}$,}\\
                & \text{$gcd(p,q) = 1$, $q > 0$}
    \end{cases}
\end{align*}
\begin{multicols}{2}
\begin{align*}
    &f_3: \mathbb{Z} \times \mathbb{Z} \to \mathbb{Z}^+ \times \mathbb{Z}^+ \\
    &f_3(~(x,y)~) = \begin{cases}
        (2x+2, 2y+2) & \text{if $x \geq 0, y \geq 0$} \\
        (-2x-1, 2y+2) & \text{if $x < 0, y \geq 0$} \\
        (2x+2, -2y+1) & \text{if $x \geq 0, y < 0$} \\
        (-2x-1, -2y-1) & \text{if $x < 0, y < 0$} \\
    \end{cases}
\end{align*}

\begin{align*}
    &f_4: \mathbb{Z}^+ \times \mathbb{Z}^+ \to \mathbb{Z}^+ \\
    &f_4(~(x,y)~) = 2^x 3^y \qquad \text{for $x,y \in \mathbb{Z}^+$}
\end{align*}
\end{multicols} \vfill
\section*{Cardinality categories}


A set $A$ is {\bf finite} means it is empty or it is the same size as $\{ 1, \ldots, n \}$ for some $n \in \mathbb{N}$.

A set $A$ is {\bf countably infinite} means it is the same size as $\mathbb{N}$. {\it Notice: 
all countably infinite sets are the same size as each other.}

A set $A$ is {\bf countable} means it is either finite or countably infinite.

A set $A$ is {\bf uncountable} means it is not countable. \vfill
\section*{Cardinality countability lemmas}


{\bf Lemmas about countable and uncountable sets}

{\bf Lemma}: If $A$ is a subset of a countable set, then it's countable.

\vspace{80pt}

{\bf Lemma}: If $A$ is a superset of an uncountable set, then it's uncountable.

\vspace{80pt}

{\bf Lemma}: If $A$ and $B$ are countable sets, then $A \cup B$ is countable
and $A \cap B$ is countable.

\vspace{80pt}

{\bf Lemma}: If $A$ and $B$ are countable sets, then $A \times B$ is countable.

{\it Generalize pairing ideas from $\mathbb{Z}^+ \times \mathbb{Z}^+$ to $\mathbb{Z}^+$}

\vspace{50pt}

{\bf Lemma}: If $A$ is a subset of $B$ , to show that $|A| = |B|$, 
it's enough to give one-to-one function from $B$ to $A$ or an onto function 
from $A$ to $B$.

\vspace{80pt}
 \vfill
\section*{Cartesian product definition}


{\bf Definition}: The {\bf Cartesian product} of the sets $A$ and $B$, 
$A \times B$, is the set of all ordered pairs $(a, b)$, where $a \in A$ and $b \in B$. 
That is: $A \times B = \{(a, b) \mid (a \in A) \land (b \in B)\}$.
The Cartesian product of the sets $A_1, A_2, \ldots ,A_n$, denoted by 
$A_1 \times A_2 \times \cdots \times A_n$, is the
set of ordered n-tuples $(a_1, a_2,...,a_n)$, where $a_i$ belongs to 
$A_i$ for $i = 1, 2,\ldots,n$. That is,
\[
    A_1 \times A_2 \times \cdots \times A_n = \{(a_1, a_2,\ldots,a_n) \mid a_i \in A_i \textrm{ for } i = 1, 2,\ldots,n\}
\] \vfill
\section*{Rna mutation insertion deletion example}


Trace the pseudocode to find the output of $\textit{mutation}(~ (\A\U\C, 3, \G) ~)$

\vspace{50pt}

Fill in the blanks so that $\textit{insertion}(~(\A\U\C, \underline{\phantom{3}}, \underline{\phantom{\G}})~) = \A\U\C\G$

\vspace{50pt}

Fill in the blanks so that $\textit{deletion}(~(\underline{\phantom{\G\G}}, \underline{\phantom{1}})~) =  \G$

\vspace{50pt}
 \vfill
\section*{Rna rnalen basecount definitions}


{\it Recall the definitions}: The set of RNA strands $S$ is defined (recursively) by:
\[
\begin{array}{ll}
\textrm{Basis Step: } & \A \in S, \C \in S, \U \in S, \G \in S \\
\textrm{Recursive Step: } & \textrm{If } s \in S\textrm{ and }b \in B \textrm{, then }sb \in S
\end{array}
\]
where $sb$ is string concatenation.

The function \textit{rnalen} that computes the length of RNA strands in $S$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{rnalen} : S & \to \mathbb{Z}^+ \\
\textrm{Basis Step:} & \textrm{If } b \in B\textrm{ then } & \textit{rnalen}(b) & = 1 \\
\textrm{Recursive Step:} & \textrm{If } s \in S\textrm{ and }b \in B\textrm{, then  } & \textit{rnalen}(sb) & = 1 + \textit{rnalen}(s)
\end{array}
\]

The function \textit{basecount} that computes the number of a given base 
$b$ appearing in a RNA strand $s$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{basecount} : S \times B & \to \mathbb{N} \\
\textrm{Basis Step:} &  \textrm{If } b_1 \in B, b_2 \in B & \textit{basecount}(~(b_1, b_2)~) & =
        \begin{cases}
            1 & \textrm{when } b_1 = b_2 \\
            0 & \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} & \textrm{If } s \in S, b_1 \in B, b_2 \in B &\textit{basecount}(~(s b_1, b_2)~) & =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 = b_2 \\
            \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 \neq b_2 \\
        \end{cases}
\end{array}
\] \vfill
\section*{Alternating quantifiers order rna examples}


{\bf Alternating nested quantifiers}



$$\forall s \in S ~\exists n \in \mathbb{N} ~(~basecount(~(s,\U)~) = n~)$$

In English: For each strand, there is a nonnnegative integer that counts the number of occurrences of $\U$ in that 
strand.\\

$$\exists n \in \mathbb{N} ~\forall s \in S ~(~basecount(~(s,\U)~) = n~)$$

In English: There is a nonnnegative integer that counts the number of occurrences of $\U$ in every 
strand.\\

\vfill

Are these statements true or false?

\newpage

$$\forall s \in S ~\exists b\in B ~(~basecount(~(s,b)~) = 3~)$$

In English: For each RNA strand there is a base that occurs 3 times in this strand.\\

Write the negation and use De Morgan's law to find a 
logically equivalent version where the negation is applied only to the 
$BC$ predicate (not next to a quantifier).

\vspace{60pt}


Is the original statement {\bf True} or {\bf False}?

\vfill
 \vfill
\section*{Proof strategies quantification finite domain}


When a predicate $P(x)$ is over a {\bf finite} domain:
\begin{itemize}
\item To show that $\forall x  P(x)$ is true: check that $P(x)$ evaluates to $T$ at each domain element by evaluating over and over. 
This is called ``Proof of universal by {\bf exhaustion}".
\item To show that $\forall x  P(x)$ is false: find a {\bf counterexample}, a domain element where $P(x)$~evaluates~to~$F$.
\item To show that $\exists x  P(x)$ is true: find a {\bf witness}, a domain element where $P(x)$ evaluates to $T$.
\item To show that $\exists x  P(x)$ is false: check that $P(x)$ evaluates to $F$ at each domain element by evaluating over and over.
DeMorgan's Law gives that $\lnot \exists x P(x) ~~\equiv~~ \forall x \lnot P(x)$ so this amounts to a proof of universal by exhaustion.
\end{itemize} \vfill
\section*{Proof strategy universal generalization}


\fbox{\parbox{\linewidth}{

{\bf New! Proof by universal generalization}: To prove that $\forall x \, P(x)$
is true, we can take an arbitrary element $e$ from the domain of 
quantification and show that $P(e)$ is true, without making any assumptions about $e$ 
other than that it comes from the domain.


An {\bf arbitrary} element of a set or domain is a fixed but unknown element from that set. 
}}
 \vfill
\section*{Quiz translating counting quantifiers}


Suppose $P(x)$ is  a predicate over a domain $D$.
\begin{enumerate}
    \item True or False: To translate the statement
    ``There are at least two  elements in $D$
    where the predicate $P$ evaluates to true", we
    could  write
    \[
    \exists  x_1 \in D \, \exists x_2 \in D  \, (P(x_1) \wedge P(x_2))
    \]
    \vfill
    \item True or False: To translate the statement
    ``There are at most two  elements in $D$
    where the predicate $P$ evaluates to true", we
    could write
    \[
    \forall  x_1 \in D \, \forall x_2 \in D \, \forall x_3 \in  D \, \left(~ (~P(x_1) \wedge P(x_2)  \wedge P(x_3) ~) \to (~ x_1 = x_2 \vee x_2 = x_3 \vee x_1 = x_3~)~\right)
    \]
    \vfill
\end{enumerate} \vfill
\section*{Proof strategies conditionals}


\fbox{\parbox{\linewidth}{

{\bf New! Proof of conditional by direct proof}: To prove that the conditional statement $p \to q$ is true, 
we can assume $p$ is true and use that assumption to show $q$ is true.
}}

\fbox{\parbox{\linewidth}{

{\bf New! Proof of conditional by contrapositive proof}: To prove that the implication $p \to q$ is true, 
we can assume $q$ is false and use that assumption to show $p$ is also false.
}}

\fbox{\parbox{\linewidth}{

{\bf New! Proof of disjuction using equivalent conditional}: To prove that the 
disjunction $p \lor q$ is true, we can rewrite it equivalently as $\lnot p \to q$ and
then use direct proof or contrapositive proof.
}} \vfill
\section*{Proof strategies proof by cases}


\fbox{\parbox{\linewidth}{{\bf New! Proof by Cases}: To prove $q$, we can 
work by cases by first describing all possible cases we might be in
and then showing that each one guarantees $q$.
Formally, if we know that $p_1 \lor p_2$ is true, 
and we can show that $(p_1 \to q)$ is true and we can show that $(p_2 \to q)$, 
then we can conclude $q$ is true.
}} \vfill
\section*{Proof strategies ands}


\fbox{\parbox{\linewidth}{
{\bf New! Proof of conjunctions with subgoals}:
To show that $p \land q$ is true, we have two subgoals: subgoal (1) prove $p$ 
is  true; and, subgoal (2) prove $q$ is true.

\vspace{1em}

 To show that $p \land q$ is false, it's enough to prove that $\lnot p$.
 
 To show that $p \land q$ is false, it's enough to prove that $\lnot q$.
}} \vfill
\section*{Sets proof strategies}


To prove that one set is a subset of another, e.g. to show $A \subseteq B$:

\vspace{50pt}

To prove that two sets are equal, e.g. to show $A = B$:

\vspace{50pt}
 \vfill
\section*{Sets equality example}


Example: $\{ 43, 7, 9 \} = \{ 7, 43, 9, 7\}$

\vspace{50pt}
 \vfill
\section*{Sets basic proofs}


{\bf Prove} or {\bf  disprove}: $\{ \A,  \C,  \U,  \G\} \subseteq \{ \A\A, \A\C, \A\U, \A\G \}$ 

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: For some set $B$, $\emptyset \in B$.

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: For every set $B$, $\emptyset \in B$.

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: The empty set is a subset of every set.

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: The empty set is a proper subset of every set.

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: $\{ 4, 6 \} \subseteq \{ n \mid  \exists c \in \mathbb{Z} ( n = 4c) \} $

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: $\{ 4, 6 \} \subseteq \{ n ~\textbf{mod}~10 \mid  \exists c \in \mathbb{Z} ( n = 4c) \} $

\vspace{150pt}

 \vfill
\section*{Proofs signposting}


\fbox{\parbox{\textwidth}{

\vspace{10pt}

Consider \ldots, an {\bf arbitrary} \ldots.
{\bf Assume} \ldots, we {\bf want to show} that \ldots. Which is what was needed,
so the proof is complete $\square$.

\vspace{20pt} {\it or, in other words:} \vspace{20pt}

Let \ldots be an {\bf arbitrary} \ldots. {\bf Assume} \ldots, {\bf WTS} that \ldots {\bf QED}.

\vspace{10pt}

}} \vfill
\section*{Set operations union intersection powerset}


{\bf Cartesian product}: When $A$ and  $B$ are sets, 
\[
    A \times  B = \{ (a,b) \mid a \in A  \wedge b  \in B \}
\]

Example: $\{43, 9\} \times  \{9, \mathbb{Z}\}  = $
    
Example: $\mathbb{Z} \times \emptyset  = $

{\bf Union}: When $A$ and  $B$ are sets,
\[
    A \cup  B = \{ x \mid x \in A  \vee x \in B \}
\]    
    
Example: $\{43, 9\} \cup \{9, \mathbb{Z}\}  = $

Example: $\mathbb{Z} \cup \emptyset  = $ 

{\bf Intersection}: When $A$ and  $B$ are sets,
\[
    A \cap  B = \{ x \mid x \in A  \wedge x \in B \}
\]    
Example: $\{43, 9\} \cap \{9,\mathbb{Z}\}  = $

Example: $\mathbb{Z} \cap \emptyset  = $


{\bf Set  difference}: When $A$ and  $B$ are sets,

\[
    A -  B = \{ x \mid x \in A  \wedge x \notin B \}
\]

Example: $\{43, 9\} - \{9, \mathbb{Z}\}  = $

Example: $\mathbb{Z} - \emptyset  = $

    
{\bf Disjoint sets}: sets $A$ and  $B$ are disjoint means $A \cap  B  = \emptyset$

Example: $\{43, 9\}, \{9, \mathbb{Z}\}$ are not  disjoint 

Example: The sets $\mathbb{Z}$ and $\emptyset$ are disjoint

    

{\bf Power set}: When $U$ is a set, $\mathcal{P}(U) = \{ X \mid X \subseteq U\}$

Example: $\mathcal{P}(\{43, 9\}) = $

Example: $\mathcal{P}(\emptyset) = $
 \vfill
\section*{Quantification definition}


The {\bf universal quantification} of predicate $P(x)$ over
domain $U$ is the statement ``$P(x)$ for all values of $x$ in the domain $U$''
and is written $\forall x P(x)$ or $\forall x \in U ~P(x)$. 
When the domain is finite, universal quantification over the domain 
is equivalent to iterated {\it conjunction} (ands).

The {\bf existential quantification} of predicate $P(x)$ 
over domain $U$ is the statement ``There exists an element $x$ 
in the domain $U$ such that $P(x)$'' and is written $\exists x P(x)$
for $\exists x \in U ~P(x)$. 
When the domain is finite, existential quantification over the domain 
is equivalent to iterated {\it disjunction} (ors).

An element for which $P(x) = F$ is called a {\bf counterexample} of $\forall x P(x)$.

An element for which $P(x) = T$ is called a {\bf witness} of $\exists x P(x)$.
 \vfill
\section*{Quantification logical equivalence}


Statements involving predicates and quantifiers are {\bf logically equivalent} 
means they have the same truth value no matter which predicates (domains and functions) 
are substituted in. 

{\bf Quantifier version of De Morgan's laws}: 
$\boxed{\neg \forall x P(x) ~\equiv~ \exists x \left( \neg P(x) \right)}$
\qquad
\qquad
$\boxed{\neg \exists x Q(x) ~\equiv~ \forall x \left( \neg Q(x) \right)}$
 \vfill
\section*{Quantification examples finite domain}


Examples of quantifications using $V(x), N(x), Mystery(x)$:

{\bf True} or {\bf False}: $\exists x~ (~V(x) \land N(x)~)$

\vfill

{\bf True} or {\bf False}: $\forall x~ (~V(x) \to N(x)~)$

\vfill

{\bf True} or {\bf False}: $\exists x~ (~N(x) \leftrightarrow Mystery(x)~)$

\vfill

Rewrite $\lnot \forall x~(~V(x) \oplus Mystery(x)~)$ into a logical equivalent statement.

\vspace{50pt}


Notice that these are examples where the predicates have {\it finite} domain.
How would we evaluate quantifications where the domain may be infinite?

\vfill

 \vfill
\section*{Rna rnalen basecount definitions}


{\it Recall the definitions}: The set of RNA strands $S$ is defined (recursively) by:
\[
\begin{array}{ll}
\textrm{Basis Step: } & \A \in S, \C \in S, \U \in S, \G \in S \\
\textrm{Recursive Step: } & \textrm{If } s \in S\textrm{ and }b \in B \textrm{, then }sb \in S
\end{array}
\]
where $sb$ is string concatenation.

The function \textit{rnalen} that computes the length of RNA strands in $S$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{rnalen} : S & \to \mathbb{Z}^+ \\
\textrm{Basis Step:} & \textrm{If } b \in B\textrm{ then } & \textit{rnalen}(b) & = 1 \\
\textrm{Recursive Step:} & \textrm{If } s \in S\textrm{ and }b \in B\textrm{, then  } & \textit{rnalen}(sb) & = 1 + \textit{rnalen}(s)
\end{array}
\]

The function \textit{basecount} that computes the number of a given base 
$b$ appearing in a RNA strand $s$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{basecount} : S \times B & \to \mathbb{N} \\
\textrm{Basis Step:} &  \textrm{If } b_1 \in B, b_2 \in B & \textit{basecount}(~(b_1, b_2)~) & =
        \begin{cases}
            1 & \textrm{when } b_1 = b_2 \\
            0 & \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} & \textrm{If } s \in S, b_1 \in B, b_2 \in B &\textit{basecount}(~(s b_1, b_2)~) & =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 = b_2 \\
            \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 \neq b_2 \\
        \end{cases}
\end{array}
\] \vfill
\section*{Predicates example rnalen basecount}


{\bf Using functions to define predicates}:

\fbox{\parbox{\textwidth}{
$L$ with domain $S \times \mathbb{Z}^+$ is defined by, for $s \in S$ and $n \in \mathbb{Z}^+$,
\[
L( ~(s, n)~) = \begin{cases}
T &\qquad\text{if $rnalen(s) = n$}\\
F &\qquad\text{otherwise}\\
\end{cases}
\]
In other words, $L(~(s,n)~)$ means $rnalen(s) = n$
}}

\vfill

\fbox{\parbox{\textwidth}{
$BC$ with domain $S \times B \times \mathbb{N}$ is defined by, 
for $s \in S$ and $b \in B$ and $n \in \mathbb{N}$,
\[
BC(~(s, b, n)~) = \begin{cases}
T &\qquad\text{if $basecount(~(s,b)~) = n$}\\
F &\qquad\text{otherwise}\\
\end{cases}
\]
In other words, $BC(~(s,b,n)~)$ means $basecount(~(s,b)~) = n$
}}


\vfill


Example where $L$ evaluates to $T$: $\underline{\phantom{(\A, 1)\hspace{1in}}}$  Why?

\vfill


Example where $BC$ evaluates to $T$: $\underline{\phantom{(\A, \A1)\hspace{1in}}}$  Why?

\vfill


Example where $L$ evaluates to $F$: $\underline{\phantom{(\A, 2)\hspace{1in}}}$ Why?

\vfill


Example where $BC$ evaluates to $F$: $\underline{\phantom{(\A, \C, 1)\hspace{1in}}}$ Why? 

\vfill


\fbox{\parbox{\textwidth}{
\[\exists t ~BC(t) \qquad \qquad 
\exists (s,b,n) \in S \times B \times \mathbb{N}~ (basecount(~(s,b)~) = n)\]

In English: \phantom{There exists an ordered $3$-tuple 
at which the predicate $BC$ evaluates to $T$.}

\vspace{30pt}

Witness that proves this existential quantification is true:\phantom{$(\G\G, \G, 2)$ or $(\G\A\U\G, \G, 2)$)}
}}

\fbox{\parbox{\textwidth}{
\[\forall t ~BC(t) \qquad \qquad 
\forall(s,b,n) \in S \times B \times \mathbb{N} ~(basecount(~(s,b)~) = n)\]

In English:\phantom{For all ordered $3$-tuples
the predicate $BC$ evaluates to $T$.}

\vspace{30pt}

Counterexample that proves this universal quantification is false: \phantom{$(\G\G, \A, 2)$ or $(\G\A\U\G, \G, 3)$)}
}}
 \vfill
\section*{Predicates projecting example rna basecount}


{\bf New predicates from old}
\begin{enumerate}
\item Define the {\bf new} predicate with domain $S \times B$ and rule
\[
basecount(~(s,b)~) = 3
\]
Example domain element where predicate is $T$: \phantom{$(\A\U\A\A, \A)$}\\

\vfill

\item Define the {\bf new} predicate with domain $S \times \mathbb{N}$ and rule
\[
basecount(~(s,\A)~) = n
\]
Example domain element where predicate is $T$: \phantom{$(\A\U\A,2)$}\\

\vfill


\item Define the {\bf new} predicate with domain $S \times B$ and rule
\[
\exists n \in \mathbb{N} ~(basecount(~(s,b)~) = n)
\]
Example domain element where predicate is $T$: \phantom{$(\A\U\A,\A)$}\\

\vfill


\item Define the {\bf new} predicate with domain $S$ and rule
\[
\forall b \in B ~(basecount(~(s,b)~) = 1)
\]
Example domain element where predicate is $T$: \phantom{$\A\C\G\U$}\\

\vfill


\end{enumerate} \vfill
\section*{Nested quantifiers}


{\bf Nested quantifiers}

\fbox{\parbox{\textwidth}{
\[
    \forall s \in S ~\forall b \in B ~\forall n \in \mathbb{N} ~(basecount(~(s,b)~) = n)
\]

In English: \phantom{There exists an ordered $3$-tuple 
at which the predicate $BC$ evaluates to $T$.}

\vspace{30pt}

Counterexample that proves this universal quantification is false:
\phantom{$(\G\G, \G, 3)$ or $(\G\A\U\G, \G, 2)$)}

\vspace{30pt}

}}

\vfill

\fbox{\parbox{\textwidth}{
\[
    ~\forall n \in \mathbb{N} ~\forall s \in S ~\forall b \in B  ~(basecount(~(s,b)~) = n)
\]

In English: \phantom{There exists an ordered $3$-tuple 
at which the predicate $BC$ evaluates to $T$.}

\vspace{30pt}

Counterexample that proves this universal quantification is false:
\phantom{$(\G\G, \G, 3)$ or $(\G\A\U\G, \G, 2)$)}

\vspace{30pt}

}}

\vfill \vfill
\section*{Alternating quantifiers strategies rna examples}


{\bf Alternating nested quantifiers}

\fbox{\parbox{\textwidth}{
$$\forall s \in S ~\exists b\in B ~(~basecount(~(s,b)~) = 3~)$$

In English: For each RNA strand there is a base that occurs 3 times in this strand.\\

Write the negation and use De Morgan's law to find a 
logically equivalent version where the negation is applied only to the 
$BC$ predicate (not next to a quantifier).

\vspace{60pt}


Is the original statement {\bf True} or {\bf False}?

}}

\vfill

\fbox{\parbox{\textwidth}{

$$\exists s \in S ~\forall b \in B ~\exists n \in \mathbb{N} ~(~basecount(~(s,b)~) = n~)$$

In English: There is an RNA strand so that for each base there is some nonnegative
integer that counts the number of occurrences of that base in this strand.\\

Write the negation and use De Morgan's law to find a 
logically equivalent version where the negation is applied only to the 
$BC$ predicate (not next to a quantifier).

\vspace{60pt}


Is the original statement {\bf True} or {\bf False}?

}}

\vfill
 \vfill
\section*{Sets proof strategies}


To prove that one set is a subset of another, e.g. to show $A \subseteq B$:

\vspace{50pt}

To prove that two sets are equal, e.g. to show $A = B$:

\vspace{50pt}
 \vfill
\section*{Sets basic proofs operations}


Let $W =  \mathcal{P}(  \{ 1,2,3,4,5\} )$

Example elements in $W$ are:
\vspace{20pt}


{\bf Prove} or {\bf  disprove}:  $\forall  A \in W\,  \forall B \in W\,  \left( A \subseteq B
~\to ~ \mathcal{P}(A) \subseteq \mathcal{P}(B) \right)$

\vfill
\vfill
\vfill

{\bf Prove} or {\bf  disprove}:  $\forall  A \in W\,  \forall B \in W\,  \left( \mathcal{P}(A)  =\mathcal{P}(B)
~\to ~ A = B \right)$

\vfill
\vfill

{\bf Prove} or {\bf  disprove}:  $\forall  A \in W\,  \forall B \in W\, \forall C  \in W\,  \left( A\cup B  = A \cup  C
~\to ~ B = C \right)$

\vfill
\vfill \vfill
\section*{Proof strategies road map}


We now have propositional and predicate logic that can help us express 
statements about any domain. We will develop proof strategies to 
craft valid argument for proving that such statements are true or disproving
them (by showing they are false). We will practice these strategies with 
statements about sets and numbers, both because they are familiar and because they
can be used to build cryptographic systems. Then we will apply proof strategies
more broadly to prove statements about data structures and machine learning 
applications. \vfill
\section*{Numbers facts}


\begin{enumerate}
    \item Addition and multiplication of real 
    numbers are each commutative and associative. 
    \vspace{25pt}
    \item The product of two positive numbers is positive, of 
    two negative numbers is positive, and of a positive and a negative number is negative.
    \vspace{25pt}
    \item The sum of two integers, the product of two integers, and the 
    difference between two integers are each integers.
    \vspace{25pt}
    \item For every integer $x$ there is no integer strictly between $x$ and $x+1$, 
    \vspace{25pt}
    \item When $x, y$ are positive integers, $xy \geq x$ and $xy \geq y$.
    \vspace{25pt}
\end{enumerate}
 \vfill
\section*{Factoring definition}


{\bf Definition}: When $a$ and $b$ are integers and $a$ is nonzero, 
{\bf $a$ divides $b$} means there is an integer $c$ such that $b = ac$ . 


Symbolically, $F(~(a,b)~) = \phantom{\exists c\in \mathbb{Z}~(b=ac)}$
and is  a predicate over the domain \underline{\phantom{$\mathbb{Z}^{\neq 0} \times \mathbb{Z}$}}


Other (synonymous) ways to say that $F(~(a,b)~)$ is true: 
\begin{center}
$a$ is a {\bf factor} of $b$
\qquad 
$a$ is a {\bf divisor} of $b$
\qquad  $b$ is a {\bf multiple} of $a$
\qquad
$a | b$
\end{center}

When $a$ is a positive integer and $b$ is any integer, $a | b$
exactly when $b \textbf{ mod } a = 0$

When $a$ is a positive integer and $b$ is any integer, $a | b$
exactly when $b = a \cdot (b \textbf{ div } a)$ \vfill
\section*{Factoring translation examples}


{\it Translate these quantified statements by matching to English statement on right.}

\begin{multicols}{2}
$\exists a\in \mathbb{Z}^{\neq 0} ~(~F(~(a,a)~)~)$

$\exists a\in \mathbb{Z}^{\neq 0} ~(~\lnot F(~(a,a)~)~)$

$\forall a\in \mathbb{Z}^{\neq 0} ~(~F(~(a,a)~)~)$

$\forall a\in \mathbb{Z}^{\neq 0} ~(~\lnot F(~(a,a)~)~)$


Every nonzero integer is a factor of itself.

No nonzero integer is a factor of itself.

At least one nonzero integer is a factor of itself.

Some nonzero integer is not a factor of itself.
\end{multicols} \vfill
\section*{Factoring basic claims}


{\bf Claim}: Every nonzero integer is a factor of itself.

{\bf Proof}: 


\vspace{150pt}


{\bf Prove} or {\bf Disprove}: There is a nonzero integer that does not divide its square.



\vspace{150pt}

{\bf Prove} or {\bf Disprove}: Every positive factor of a positive integer is less than or equal to it.

\vspace{150pt}
 \vfill
\section*{Factoring basic claims continued}


{\bf Claim}: Every nonzero integer is a factor of itself and 
every nonzero integer divides its square.

\vspace{100pt}
 \vfill
\section*{Factoring even odd}


{\bf Definition}: an integer $n$ is {\bf even} means that there is an integer $a$ such that $n = 2a$; 
an integer $n$ is {\bf odd} means that there is an integer $a$ such that $n = 2a+1$.  Equivalently, 
an integer $n$ is {\bf even} means $n ~\textbf{ mod }~2 = 0$; an integer $n$ is {\bf odd} means $n ~\textbf{ mod }~2 = 1$.  
Also, an integer is even if and only if it is not odd.
 \vfill
\section*{Prime number definition}


{\bf Definition}:  An integer $p$ greater than $1$ is called {\bf prime} means 
the only positive factors of 
$p$ are $1$ and $p$. A positive integer that is greater than $1$ and is not prime 
is called composite. \vfill
\section*{Primes basic claims}


{\it Extra examples}: Use the definition to prove that $1$ is not prime, $2$ is prime, $3$
is prime, $4$ is not prime, $5$ is prime, $6$ is not prime, and $7$ is prime.


{\bf True or False}: The statement ``There are three consecutive positive integers that are prime."

{\it Hint}: These numbers would be of the form $p, p+1, p+2$ (where $p$ is a positive integer).

{\bf Proof}: We need to show \underline{\phantom{$\exists p \in \mathbb{Z}^+ ~(~Pr(p) \land Pr(p+1) \land Pr(p+2)~)$}}

\vspace{200pt}

{\bf True or False}: The statement ``There are three consecutive odd positive integers that are prime."

{\it Hint}: These numbers would be of the form $p, p+2, p+4$ (where $p$ is an odd positive integer).

{\bf Proof}: We need to show \underline{\phantom{$\exists p \in \mathbb{Z}^+ ~(~(p \textbf{ mod } 2 = 1 \land Pr(p) \land Pr(p+2) \land Pr(p+4)~)$}}

\vspace{200pt}
 \vfill
\section*{Rna rnalen basecount definitions}


{\it Recall the definitions}: The set of RNA strands $S$ is defined (recursively) by:
\[
\begin{array}{ll}
\textrm{Basis Step: } & \A \in S, \C \in S, \U \in S, \G \in S \\
\textrm{Recursive Step: } & \textrm{If } s \in S\textrm{ and }b \in B \textrm{, then }sb \in S
\end{array}
\]
where $sb$ is string concatenation.

The function \textit{rnalen} that computes the length of RNA strands in $S$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{rnalen} : S & \to \mathbb{Z}^+ \\
\textrm{Basis Step:} & \textrm{If } b \in B\textrm{ then } & \textit{rnalen}(b) & = 1 \\
\textrm{Recursive Step:} & \textrm{If } s \in S\textrm{ and }b \in B\textrm{, then  } & \textit{rnalen}(sb) & = 1 + \textit{rnalen}(s)
\end{array}
\]

The function \textit{basecount} that computes the number of a given base 
$b$ appearing in a RNA strand $s$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{basecount} : S \times B & \to \mathbb{N} \\
\textrm{Basis Step:} &  \textrm{If } b_1 \in B, b_2 \in B & \textit{basecount}(~(b_1, b_2)~) & =
        \begin{cases}
            1 & \textrm{when } b_1 = b_2 \\
            0 & \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} & \textrm{If } s \in S, b_1 \in B, b_2 \in B &\textit{basecount}(~(s b_1, b_2)~) & =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 = b_2 \\
            \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 \neq b_2 \\
        \end{cases}
\end{array}
\] \vfill
\section*{Alternating quantifiers proofs rna examples}


Which proof strategies could be used to prove each of the following statements?

{\it Hint: first translate the statements to English and identify the main logical structure.}

$\forall s \in S~(~rnalen(s) > 0~)$

\vspace{100pt}

$\forall b \in B~\exists s \in S~(~basecount(~(s,b)~)~ > 0~)$

\vspace{100pt}

$\forall s \in S ~\exists b\in B ~(~basecount(~(s,b)~) > 0~)$

\vspace{100pt}

$\exists s \in S \, (\textit{rnalen(s)} = \textit{basecount}(~(s, \A)~)$

\vspace{100pt}

$\forall s \in S \, (\textit{rnalen(s)} \geq \textit{basecount}(~(s, \A)~))$

\vspace{100pt}

 \vfill
\section*{Structural induction motivating example rna}


{\bf Claim} $\forall s \in S ~(~rnalen(s) > 0~)$

{\bf Proof}: Let $s$ be an arbitrary RNA strand. By the recursive definition of $S$,
either $s \in B$ or there is some strand $s_0$ and some base $b$ such that $s = s_0 b$.
We will show that the inequality holds for both cases.

{$\phantom{Basis}$} {\bf Case}: Assume $s \in B$. We need to show $rnalen(s) > 0$. 
By the basis step in the definition of $rnalen$,
$$rnalen(s) = 1$$
which is greater than $0$, as required.

{$\phantom{Recursive}$} {\bf Case}: Assume there is some strand $s_0$ and some base $b$ 
such that $s = s_0 b$. We will show {\it (the stronger claim)} that 
\[
    \forall u \in S ~\forall b \in B ~( ~\textit{rnalen}(u) >0  \to 
    \textit{rnalen}(ub) >0 ~)
\]
Consider an arbitrary RNA strand $u$ and an arbitrary base $b$, and assume towards a
direct proof,$~~{\phantom{ this is the induction hypothesis}}~~$ that
\[
    rnalen(u) > 0
\]
We need to show that $rnalen(ub) > 0$.
\[
    rnalen(ub) = 1 + rnalen (u) > 1 + 0 = 1 > 0
\]
as required. \vfill
\section*{Proof strategies structural induction}


\fbox{\parbox{\textwidth}{{\bf Proof by Structural Induction} 
To prove a universal quantification over a recursively defined set:
\begin{itemize}
    \item[] {\bf Basis Step}:  Show the statement holds for elements specified in the basis step of the definition.
    \item[]  {\bf Recursive Step}:  Show that if the statement is true for each of the elements used to construct
    new elements in the recursive step of the definition, the result holds for these new elements.
    \end{itemize}
}}
     \vfill
\section*{Structural induction example rnalen basecount}


{\bf Claim} $\forall s \in S \, (\textit{rnalen(s)} \geq \textit{basecount}(~(s, \A)~))$:

{\bf Proof}: We proceed by structural induction on the recursively defined set $S$.

{\bf Basis  Case}: We need to prove that 
the inequality holds for each element in the basis step of the recursive
definition of $S$. 
Need to show 
\begin{align*}
          &(~ rnalen(\A) \geq basecount(~(\A, \A)~)~) \land (~ rnalen(\C) \geq basecount(~(\C, \A)~)~) \\
    \land & (~ rnalen(\U) \geq basecount(~(\U, \A)~)~) \land (~ rnalen(\G) \geq basecount(~(\G, \A)~)~)
\end{align*}
We calculate, using the definitions of $rnalen$ and $basecount$:

\vspace{100pt}

{\bf Recursive Case}: We will prove that 
\[
    \forall u \in S ~\forall b \in B ~( ~rnalen(u) \geq basecount(~(u, \A)~) \to 
    rnalen(ub) \geq basecount(~(ub, \A)~)
\]

Consider arbitrary RNA strand $u$ and arbitrary base $b$. Assume, as the {\bf induction hypothesis},
that $rnalen(u) \geq basecount(~(u,\A)~)$. We need to show that $rnalen(ub) \geq basecount(~(ub, \A)~)$.

Using the recursive step in the definition of the function $rnalen$:
\[
    rnalen(ub) = 1 + rnalen(u)
\]
The recursive step in the definition of the function $basecount$ has two cases. We notice that 
$b = \A \lor b \neq \A$ and we proceed by cases.

{\it Case i.} Assume $b = \A$.

Using the first case in the recursive step in the definition of the function $basecount$:
\[
    basecount(~(ub, \A)~) = 1 + basecount(~(u,\A)~)
\]
By the {\bf induction hypothesis}, we know that $basecount(~(u,\A)~) \leq rnalen(u)$ so:
\[
    basecount(~(ub, \A)~) = 1 + basecount(~(u,\A)~) \leq 1 + rnalen(u) = rnalen (ub)
\]
and, thus, $basecount(~(ub,\A)~) \leq rnalen(ub)$, as required.

{\it Case ii.} Assume $b \neq \A$. 

Using the second case in the recursive step in the definition of the function $basecount$:
\[
    basecount(~(ub, \A)~) = basecount(~(u,\A)~)
\]
By the {\bf induction hypothesis}, we know that $basecount(~(u,\A)~) \leq rnalen(u)$ so:
\[
    basecount(~(ub, \A)~) = basecount(~(u,\A)~) \leq rnalen(u) < 1 + rnalen(u) = rnalen (ub)
\]
and, thus, $basecount(~(ub,\A)~) \leq rnalen(ub)$, as required.
 \vfill
\section*{Proofs signposting kinds of claims}


To organize our proofs, it's useful to highlight which claims are most important for 
our overall goals.
We use some terminology to describe different roles statements can have.

{\bf Theorem}: Statement that can be shown to be true, usually an important one.

Less important theorems can be called {\bf proposition}, {\bf fact}, {\bf result}, {\bf claim}.

{\bf Lemma}: A less important theorem that is useful in proving a theorem.
 
{\bf Corollary}: A theorem that can be proved directly after another one has been proved, 
without needing a lot of extra work.

{\bf Invariant}: A theorem that describes a property that is true about an algorithm or 
system no matter what inputs are used.




 \vfill
\section*{Structural induction example sum of powers}


The set $\mathbb{N}$ is recursively defined.
Therefore, the function $sumPow: \mathbb{N} \to \mathbb{N}$
which computes, for input $i$, the sum of the nonnegative powers of $2$
up to and including exponent $i$ is defined
recursively by

\begin{alignat*}{2}
    \text{Basis step:  } \qquad & sumPow(0) = 1 &\\
    \text{Recursive step:  } & \text{If } x \in \mathbb{N} \text{, then } &sumPow(x+1) = sumPow(x) + 2^{x+1}
\end{alignat*}

$sumPow(0) =$

\vspace{20pt}

$sumPow(1) =$

\vspace{20pt}

$sumPow(2) =$

\vspace{20pt}


Fill in the blanks in the following proof of 
\[
    \forall n \in \mathbb{N}~(sumPow(n) = 2^{n+1} - 1)
\]

{\bf Proof}: Since $\mathbb{N}$ is recursively defined, we proceed by \underline{\phantom{structural induction \hspace{0.3in}}}.

{\bf Basis case}: We need to show that \underline{\phantom{$sumPow(0) = 2^{0+1} - 1$ \hspace{0.2in}}}.
Evaluating each side: $LHS = sumPow(0) = 1$ by the basis case in the recursive definition
of $sumPow$; $RHS = 2^{0+1} - 1 = 2^1 - 1 = 2-1 = 1$. Since $1=1$, the equality holds.

{\bf Recursive case}: Consider arbitrary natural number $n$ and assume, as the 
\underline{\phantom{Induction Hypothesis (IH)}} that $sumPow(n) = 2^{n+1} - 1$. We need to show that
\underline{\phantom{$sumPow(n+1) = 2^{(n+1) + 1} - 1$}}.  Evaluating each side: 
\[
LHS = sumPow(n+1) \overset{\text{rec def}}{=} sumPow(n)  + 2^{n+1}\overset{\text{IH}}{=} (2^{n+1} - 1) + 2^{n+1}.
\]
\[
RHS = 2^{(n+1)+1}- 1 \overset{\text{exponent rules}}{=} 2 \cdot 2^{n+1} -1  = \left(2^{n+1} + 2^{n+1} \right) - 1
\overset{\text{regrouping}}{=}  (2^{n+1} - 1) + 2^{n+1} 
\]
Thus, $LHS = RHS$. The structural induction is complete and we have proved the universal generalization.
$\square$

 \vfill
\section*{Proof strategy mathematical induction}


\fbox{\parbox{\textwidth}{

{\bf Proof by Mathematical Induction}

To prove a universal quantification over the set of all integers greater than
or  equal to some  base integer $b$,

\vspace{-10pt}

\begin{itemize}
\item[] {\bf Basis Step}:  Show the property holds for $b$. 
\item[]  {\bf Recursive Step}:  Consider an arbitrary integer $n$ greater than or  equal to  $b$, assume
    (as the {\bf induction hypothesis})  that the property holds  for $n$, and use  this and
    other facts to  prove that  the property holds for $n+1$.
\end{itemize}

}} \vfill
\section*{Induction dominos}


\begin{center}
    \includegraphics[width=2in]{../../resources/images/Domino_Cascade.jpeg}

    {\tiny Wikimedia commons\\ \href{https://creativecommons.org/licenses/by/2.0/legalcode}{https://creativecommons.org/licenses/by/2.0/legalcode} }
\end{center} \vfill
\section*{Proof strategy mathematical induction}


\fbox{\parbox{\textwidth}{

{\bf Proof by Mathematical Induction}

To prove a universal quantification over the set of all integers greater than
or  equal to some  base integer $b$,

\vspace{-10pt}

\begin{itemize}
\item[] {\bf Basis Step}:  Show the property holds for $b$. 
\item[]  {\bf Recursive Step}:  Consider an arbitrary integer $n$ greater than or  equal to  $b$, assume
    (as the {\bf induction hypothesis})  that the property holds  for $n$, and use  this and
    other facts to  prove that  the property holds for $n+1$.
\end{itemize}

}} \vfill
\section*{Proof strategy strong induction}


\fbox{\parbox{\textwidth}{

{\bf Proof by Strong Induction}

To prove that a universal quantification over the set of all integers greater than or equal to some  base integer $b$ holds,  pick a  fixed nonnegative integer  $j$ and then: \hfill 

\begin{tabularx}{\textwidth}{lX}
    {\bf Basis Step}: & Show the statement holds for $b$, $b+1$, \ldots, $b+j$. \\
    {\bf Recursive Step}: & Consider an arbitrary integer $n$ greater than or  equal to $b+j$, assume
    (as the {\bf strong  induction hypothesis})  that the property holds  for {\bf each of} $b$, $b+1$, \ldots, $n$, 	
    and use  this and
    other facts to  prove that  the property holds for $n+1$.
\end{tabularx}
}} 
 \vfill
\section*{Binary expansions exist proof}


{\bf Theorem}: Every positive integer is a sum of (one or more) distinct powers of $2$.
{\it Binary expansions exist!}

Recall the definition for binary expansion:



{\bf Definition} For $n$ a positive integer, 
the {\bf binary expansion of $n$}  is
\[
(a_{k-1} \cdots a_1 a_0)_b
\]
where $k$ is a positive integer, $a_0, a_1, \ldots, a_{k-1}$ 
are each $0$ or $1$, $a_{k-1} \neq  0$, and
\[
n =  \sum_{i=0}^{k-1} a_{i} b^{i}
\]
 

The idea in the ``Least significant first" algorithm 
for computing binary expansions is that the binary
expansion of {\it half} a number becomes {\it part} of the binary expansion of 
the number of itself. We can use this 
idea in a proof by strong induction that binary expansions exist for all 
positive integers $n$.


{\bf Proof by strong induction}, with $b=1$ and $j=0$.


{\bf Basis step}:  WTS property is true about  $1$.

\phantom{Choose $a_0 = 1$, then $(a_0)_2 = 1 \cdot 2^0 = 1$.}
\vspace{80pt}


{\bf Recursive step}: Consider an arbitrary integer $n \geq 1$.

Assume (as the strong induction hypothesis, IH) that the property is true about  each of $1, \ldots, n$.  

WTS that the property is true about $n+1$.

{\it Idea}: We will apply the IH to $(n+1) \textbf{ div } 2$.

{\it Why is this ok?}

\phantom{Notice that $(n+1) \textbf{ div } 2$ is greater than or equal to 
$1$ and less than or equal to $n$ because $n \geq 1$.}
\vspace{100pt}

{\it Why is this helpful?}

By the IH, we can write $(n+1) \textbf{ div } 2$ as 
a sum of powers of $2$. In other words, 
there are values $a_{k-1}, \ldots, a_0$ such that each $a_i$ is $0$ or $1$, $a_{k-1} = 1$, 
and
\[
    \sum_{i=0}^{k-1} a_i 2^i = (n+1) \textbf{ div } 2   
\]
Define the collection of coefficients
\[
   c_{j} = 
   \begin{cases}
        a_{j-1} \qquad&\text{if $1 \leq j \leq k$}\\
        (n+1) \textbf{ mod } 2 &\text{if $j = 0$}
   \end{cases}
\]
Calculating: 
\begin{alignat*}{2}
    \sum_{j=0}^k c_j 2^j &= c_0 + \sum_{j=1}^k c_j 2^j 
    = c_0 + \sum_{i=0}^{k-1} c_{i+1} 2^{i+1} &\qquad &\text{re-indexing the summation}\\
    &= c_0 + 2 \cdot \sum_{i=0}^{k-1} c_{i+1}2^i &\qquad &\text{factoring out a $2$ from each term in the sum}\\
    &= c_0 + 2 \cdot \sum_{i=0}^{k-1} a_{i} 2^i &\qquad &\text{by definition of $c_{i+1}$}\\
    &= c_0 + 2 \left(~(n+1) \textbf{ div } 2 ~\right) &\qquad &\text{by IH} \\
    &= \left(~ (n+1) \textbf{ mod } 2 ~\right ) + 2 \left(~(n+1) \textbf{ div } 2 ~\right) &\qquad &\text{by definition of $c_0$} \\
    &= n+1 &\qquad&\text{by definition of long division}
\end{alignat*}

Thus, $n+1$ can be expressed as a sum of powers of $2$, as required. \vfill
\section*{Linked lists definition}


{\bf Definition} The set of linked lists of natural numbers $L$ is defined recursively by
\[
\begin{array}{ll}
    \textrm{Basis Step: } & [] \in L \\
    \textrm{Recursive Step: } & \textrm{If } l \in L\textrm{ and }n \in \mathbb{N} \textrm{, then } (n, l) \in L
\end{array}
\] \vfill
\section*{Linked lists examples}


Visually:

\vspace{50pt}

Example: the list with two nodes whose first node has $20$ and whose second node
has $42$

\vspace{50pt} \vfill
\section*{Linked list length definition}


{\bf Definition}: The length of a linked list of natural numbers $L$, $length: L \to \mathbb{N}$ is defined by
\[
\begin{array}{llll}
\textrm{Basis Step:} &  & length(~[]~) &= 0 \\
\textrm{Recursive Step:} & \textrm{If } l \in L\textrm{ and }n \in \mathbb{N}\textrm{, then  } & length(~(n, l)~)  &= 1+ length(l)
\end{array}
\]
 \vfill
\section*{Linked lists prepend definition}


{\bf Definition}: The function $prepend : L \times \mathbb{N} \to L$ that adds an element at the 
front of a linked list is defined by
\[
\phantom{prepend(~(l, n)~) = (n, l)}
\]
 \vfill
\section*{Linked list append definition}


{\bf Definition} The function $append : L \times \mathbb{N} \to L$ that 
adds an element at the end of a linked list is defined by
\[
\begin{array}{llll}
\textrm{Basis Step:} & \textrm{If } m \in \mathbb{N}\textrm{ then } & \phantom{append(~([], m)~)} & \phantom{= (m, []) }\\
\textrm{Recursive Step:} & \textrm{If } l \in L\textrm{ and }n \in \mathbb{N}\textrm{ and }m \in \mathbb{N}\textrm{, then  } & \phantom{append(~(~(n, l), m~)~) } &\phantom{= (n, append(~(l, m)~)~)}
\end{array}
\] \vfill
\section*{Linked list append length claim proof}


{\bf Claim}: $\forall l \in L ~ (~length(~append(~(l, 100)~)~) > length(l)~)$

{\bf Proof:} By structural induction on $L$, we have two cases:

{\bf Basis Step}

    \begin{tabular}{l p{3.5in}}
     1. \textbf{To Show} $length(~append(~([], 100)~)~) > length(~[]~)$
    & Because $[]$ is the only element defined in the basis step of $L$, 
    we only need to prove that the property holds for $[]$.\\
    &  \\
     2. \textbf{To Show} $length(~(100,[])~) > length(~[]~)$
    &  By basis step in definition of $append$.\\
    &  \\
     3. \textbf{To Show} $(1 +length(~[]~)) > length(~[]~)$
    &  By recursive step in definition of $length$.\\
    &  \\    
     4. \textbf{To Show} $1+0 > 0$
    &  By basis step in definition of $length$.\\
    &  \\    
    5. $T$
    & By properties of integers \\
    &  \\    
    QED & Because we got to $T$ only by rewriting \textbf{To Show} to equivalent statements, using well-defined proof techniques, and applying definitions. \\
    \end{tabular}

{\bf Recursive Step}

Consider an arbitrary: $l' \in L$, $n \in \mathbb{N}$, and we  assume
as the {\bf induction hypothesis} that:
\[
length(~append(~(l', 100~)~)~) > length(l')
\]
Our goal is to show that $length(~append( ~(~(n,l'), 100~)~)~) > length(~(n,l')~)$ is also true. 
We start by working with
one side of the candidate inequality:
\begin{align*}
LHS &= length(~append( ~(~ (n,l'), 100~)~)~) \\
&= length(~(n, append(~(l', 100)~)~ )~) \qquad \text{by the recursive definition of $append$}\\
&= 1 + length(~ append(~(l', 100)~) ~) \qquad \text{by the recursive definition of $length$}\\
&> 1+ length(l')  \qquad \text{by the induction hypothesis}\\
&= length( (n,l') )  \qquad \text{by the recursive definition of $length$}\\
&= RHS 
\end{align*} \vfill
\section*{Linked list example each length}


Prove or disprove: $\forall n \in \mathbb{N} ~\exists l \in L ~(~length(l) = n~)$

\vspace{300pt} \vfill
\section*{Proof strategy proof by contradiction}


\fbox{\parbox{\textwidth}{

{\bf New! Proof by Contradiction} 

To prove that a statement $p$ is true, pick another statement $r$ and once we show
that $\neg p  \to (r \wedge  \neg r)$ then  we can conclude that  $p$ is  true.

{\it Informally} The statement we care about can't possibly be false, so it must be true.
}} 

 \vfill
\section*{Rational numbers definition}


The {\bf set  of rational numbers}, $\mathbb{Q}$  is defined as 
\[
\left\{ \frac{p}{q} \mid p \in \mathbb{Z}  \text{ and  } q  \in \mathbb{Z} \text{ and } q \neq  0 \right\}
\text{~~~~or, equivalently,~~~~}
\{ x  \in  \mathbb{R} \mid \exists p \in \mathbb{Z}  \exists q \in \mathbb{Z}^+ ( p =  x \cdot q) \}
\]

{\it Extra practice}: Use the definition of set equality to prove that the definitions above  give the same set.

 \vfill
\section*{Proof by contradiction irrational}


{\bf Goal}:  The square root of $2$ is not a rational number.  In other words: $\neg \exists x \in \mathbb{Q} ( x^2 -  2 = 0)$

{\bf Attempted proof}: The definition of the set of rational numbers is the collection of fractions $p/q$ where $p$ is an integer and $q$ is a nonzero integer. Looking for a {\bf witness} $p$ and $q$, we can write the square root of $2$ as the fraction 
$\sqrt{2 }/1$, where $1$ is a nonzero integer. Since the numerator is not in the domain, this witness is not allowed, and we have shown that the square root of $2$ is not a fraction of integers (with nonzero denominator). Thus, the square root of $2$ is not rational.


{\it The problem in the above attempted proof is that} \underline{\phantom{it only considers one candidate witness
and does not prove that no witnesses exist.}}


{\bf Lemma 1:} For every two integers $a$ and  $b$, not both zero, with  $gcd(~(a,b)~) = 1$, it is not the case that both $a$
is  even and $b$ is even.


{\bf Lemma 2:} For every integer  $x$, $x$ is  even if and only if $x^2$  is even.


{\bf Proof}: Towards a proof by contradiction, we will define a statement 
$r$ such that $\sqrt{2} \in \mathbb{Q} \to (r \land \lnot r)$. 

Assume that $\sqrt{2} \in \mathbb{Q}$. Namely, there are positive integers
$p, q$ such that 
\[
    \sqrt{2} = \frac{p}{q}
\]
Let $a= \frac{p}{gcd( ~(p,q)~)}$, $b = \frac{q}{gcd(~(p,q)~)}$, then 
\[
    \sqrt{2} = \frac{a}{b} \qquad \text{and} \qquad gcd(~(a,b)~) = 1
\]

By Lemma 1, $a$ and $b$ are not both even. We define $r$ to be the 
statement ``$a$ is even and $b$ is even'', and we have proved $\lnot r$.

Squaring both sides and clearing denominator: $2b^2 = a^2$.

By definition of even, since $b^2$ is an integer$, a^2$ is even.

By Lemma 2, this guarantees that $a$ is even too. So, by 
definition of even, there is some integer (call it $c$), such that $a = 2c$.

Plugging into the equation:
\[
    2b^2 = a^2 = (2c)^2 = 4c^2
\]
and dividing both sides by $2$
\[
    b^2 = 2c^2
\]
and since $c^2$ is an integer, $b^2$ is even. By Lemma 2, $b$ is even too.
Thus, $a$ is even and $b$ is even and we have proved $r$. 

In other words, assuming that $\sqrt{2} \in \mathbb{Q}$ guarantees $r \land \lnot r$, 
which is impossible, so $\sqrt{2} \notin \mathbb{Q}$. QED

 \vfill
\section*{Tautology contradiction contingency examples}


Label each of the following as a tautology, contradiction, or contingency.

$p \land p$

\vfill

$p \oplus p$

\vfill

$p \lor p$

\vfill

$p \lor \lnot p$

\vfill

$p \land \lnot p$

\vfill

 \vfill
\section*{Why represent numbers}


Modeling uses data-types that are encoded in a computer.
The details of the encoding impact the efficiency of algorithms
we use to understand the systems we are modeling and the 
impacts of these algorithms on the people using the systems.
Case study: how to encode numbers?

\phantom{
Positional representation with familiar (decimal) number encodings
\vspace{30pt}
}
\vfill \vfill
\section*{Fixed width definition}


{\bf Definition} For $b$ an integer greater than $1$, $w$ a positive integer, 
and $n$ a nonnegative integer
$\underline{\phantom{\hspace{1in}}}$, ~
the {\bf base $b$ fixed-width $w$ expansion of $n$}  is
\[
(a_{w-1} \cdots a_1 a_0)_{b,w}
\]
where  $a_0, a_1, \ldots, a_{w-1}$ are nonnegative integers less than $b$ and
\[
n =  \sum_{i=0}^{w-1} a_{i} b^{i}
\]
 \vfill
\section*{Fixed width example}


\begin{center}
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    Decimal &  Binary  & Binary fixed-width $10$& Binary fixed-width $7$ & Binary fixed-width $4$\\
    $b=10$ & $b=2$ & $b=2$, $w =  10$& $b=2$, $w =  7$& $b=2$, $w =  4$ \\
    \hline 
    &&&&  \\
    $(20)_{10}$&\phantom{$(10100)_{2}$\qquad\qquad}&&  &\\
    &&&&  \\
\hline
    \end{tabular}
    \end{center}
 \vfill
\section*{Fixed width fractional definition}


{\bf Definition} For $b$ an integer greater than $1$, $w$ a positive integer, 
$w'$ a positive  integer, and $x$ a real number the {\bf base $b$ fixed-width 
expansion of $x$ with integer part width $w$  and fractional part width $w'$} is
$(a_{w-1} \cdots a_1 a_0 .  c_{1} \cdots c_{w'})_{b,w,w'}$
where  $a_0, a_1, \ldots, a_{w-1}, c_1, \ldots, c_{w'}$ are nonnegative integers less than $b$ and
$$x \geq \sum_{i=0}^{w-1} a_{i} b^{i} + \sum_{j=1}^{w'}  c_{j} b^{-j} \hfill
\textrm{\qquad and \qquad}
\hfill x < \sum_{i=0}^{w-1} a_{i} b^{i} + \sum_{j=1}^{w'} c_{j} b^{-j} + b^{-w'}$$

\begin{center}
\begin{tabular}{|c|p{5in}|}
\hline
& \\
$3.75$  in fixed-width binary,& \\
integer part width $2$,&\\
 fractional part width $8$ & \\
& \\
& \\
& \\
& \\
\hline
& \\
$0.1$  in fixed-width binary, & \\
integer part width $2$, &\\
 fractional part width $8$ & \\
 & \\
 & \\
 & \\
 & \\
 \hline
\end{tabular}
\end{center}

\vfill

\includegraphics[width=2in]{../../resources/images/ArithmeticDemo.png}

Note: Java uses floating point, not fixed width representation, but similar rounding errors appear in both.
 \vfill
\section*{Negative int expansions}


{\bf Representing negative integers in binary}: Fix a positive integer  width for the representation  $w$, $w >1$.

\begin{tabular}{|cc|p{3.4in}|p{3.7in}|}
\hline
& & To  represent a positive integer $n$ & To represent a negative integer $-n$\\
\hline
&& &  \\
&\parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{Sign-magnitude}}} &
$[ 0a_{w-2} \cdots a_0]_{s,w}$, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$& 
$[1a_{w-2} \cdots a_0]_{s,w}$
, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$\\
&& & \\
&& Example $n=17$, $w=7$:  & Example $-n=-17$, $w=7$: \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
\hline
&&  &  \\
&\parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{2s complement}}} &
$[0a_{w-2} \cdots a_0]_{2c,w}$, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$& $[1a_{w-2} \cdots a_0]_{2c,w}$, where $2^{w-1} - n =  (a_{w-2} \cdots a_0)_{2,w-1}$\\
&& & \\
&& Example $n=17$, $w=7$:  & Example $-n=-17$, $w=7$: \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
\hline
\end{tabular} \vfill
\section*{Calculating 2s complement}


For positive integer $n$, to represent $-n$ in 
$2$s complement with width $w$,
\begin{itemize}
    \item Calculate $2^{w-1} - n$, convert 
    result to binary fixed-width $w-1$, pad 
    with leading $1$, or
    \item Express $-n$ as a sum of powers of $2$, 
    where the leftmost $2^{w-1}$ is negative weight, or
    \item Convert $n$ to binary fixed-width $w$, 
    flip bits, add 1 (ignore overflow)
\end{itemize}

{\it Challenge: use definitions to explain why
each of these approaches works.} \vfill
\section*{Representing zero}


{\bf Representing $0$}:

So far, we have representations for
positive and negative integers. What about $0$?

\begin{tabular}{|cc|p{3.4in}|p{3.7in}|}
   \hline
   & & To  represent a {\bf non-negative} integer $n$ & To represent a {\bf non-positive} integer $-n$\\
   \hline
   && &  \\
   &\parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{Sign-magnitude}}} &
   $[ 0a_{w-2} \cdots a_0]_{s,w}$, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$& 
   $[1a_{w-2} \cdots a_0]_{s,w}$
   , where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$\\
   && & \\
   && Example $n=0$, $w=7$:  & Example $-n=0$, $w=7$: \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
\hline
   &&  &  \\
   &\parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{2s complement}}} &
   $[0a_{w-2} \cdots a_0]_{2c,w}$, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$& $[1a_{w-2} \cdots a_0]_{2c,w}$, where $2^{w-1} - n =  (a_{w-2} \cdots a_0)_{2,w-1}$\\
   && & \\
   && Example $n=0$, $w=7$:  & Example $-n=0$, $w=7$: \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
\hline
\end{tabular} \vfill
\section*{Equivalence relation definition}


A relation is an {\bf equivalence relation} means it is reflexive, symmetric, and transitive. \vfill
\section*{Partial order definition}


A relation is a {\bf partial ordering} (or partial order) means 
it is reflexive, antisymmetric, and transitive. \vfill
\section*{Hasse diagram definition}


For a partial ordering, its {\bf Hasse diagram} is a graph representing the 
relationship between elements in the ordering. The nodes (vertices) of the graph 
are the elements of the 
domain of the binary relation. The edges do not have arrow heads. The
directionality of the partial order is indicated by 
the arrangements of the nodes. The nodes are arranged so that nodes connected to nodes
above them by edges indicate that the relation holds between the 
lower node and the higher node. 
Moreover, the diagram omits self-loops and 
omits edges that are guaranteed by transitivity.
 \vfill
\section*{Hasse diagram example}


Draw the Hasse diagram of the partial order on the set $\{a,b,c,d,e,f,g\}$ defined as
\begin{align*}
    \{  &(a,a), (b,b), (c,c), (d,d), (e,e), (f,f), (g,g), \\
        &(a,c), (a,d), (d,g), (a,g), (b,f), (b,e), (e,g), (b,g) \}
\end{align*}

\vspace{100pt}

%
 \vfill
\section*{Partition definition}


A {\bf partition} of a set $A$ is a set of non-empty, disjoint subsets 
$A_1, A_2, \cdots, A_n$ such that 
\[
    A = \bigcup_{i=1}^{n} A_i = \{ x \mid \exists i (x \in A_i) \}
\] \vfill
\section*{Equivalence class definition}


An {\bf equivalence class} of an element $a \in A$ 
with respect to an equivalence relation $R$ on the set $A$ is the set 
\[
    \{s \in A \mid (a, s) \in R \}
\] 
We write $[a]_R$ for this set, which is the equivalence class of $a$ with respect to $R$. \vfill
\section*{Congruence classes mod four}


{\it Recall}: We say $a$ is {\bf congruent to} $b$ \textbf{mod} $n$ 
means $(a, b) \in R_{(\textbf{mod } n)}$. 
A common notation is to write this as $a \equiv b (\textbf{mod } n)$.

We can partition the set of integers using equivalence classes of  $R_{(\textbf{mod } 4)}$

\begin{align*}
    [0]_{R_{(\textbf{mod } 4)}} &= \phantom{ \{ x \in \mathbb{Z} \mid x \equiv 0 ((\textbf{mod } 4)) \} 
    = \{ x \in \mathbb{Z} \mid x \textbf{ mod } 4 = 0 \textbf{ mod } 4 = 0 \} = \{ 4c \mid c \in \mathbb{Z}\} }\\
    [1]_{R_{(\textbf{mod } 4)}} &= \phantom{ \{ x \in \mathbb{Z} \mid x \equiv 1 ((\textbf{mod } 4)) \} 
    = \{ x \in \mathbb{Z} \mid x \textbf{ mod } 4 = 1 \textbf{ mod } 4 = 1 \} = \{ 4c+1 \mid c \in \mathbb{Z}\} }\\
    [2]_{R_{(\textbf{mod } 4)}} &= \phantom{ \{ x \in \mathbb{Z} \mid x \equiv 2 ((\textbf{mod } 4)) \} 
    = \{ x \in \mathbb{Z} \mid x \textbf{ mod } 4 = 2 \textbf{ mod } 4 = 0 \} = \{ 4c+2 \mid c \in \mathbb{Z}\} }\\
    [3]_{R_{(\textbf{mod } 4)}} &= \phantom{ \{ x \in \mathbb{Z} \mid x \equiv 3 ((\textbf{mod } 4)) \} 
    = \{ x \in \mathbb{Z} \mid x \textbf{ mod } 4 = 3 \textbf{ mod } 4 = 3 \} = \{ 4c+3 \mid c \in \mathbb{Z}\} }\\
    [4]_{R_{(\textbf{mod } 4)}} &= \phantom{ \{ x \in \mathbb{Z} \mid x \equiv 4 ((\textbf{mod } 4)) \} 
    = \{ x \in \mathbb{Z} \mid x \textbf{ mod } 4 = 4 \textbf{ mod } 4 = 0 \} = \{ 4c \mid c \in \mathbb{Z}\} }\\
    [5]_{R_{(\textbf{mod } 4)}} &= \phantom{ \{ x \in \mathbb{Z} \mid x \equiv 5 ((\textbf{mod } 4)) \} 
    = \{ x \in \mathbb{Z} \mid x \textbf{ mod } 4 = 5 \textbf{ mod } 4 = 1 \} = \{ 4c+1 \mid c \in \mathbb{Z}\} }\\
    [-1]_{R_{(\textbf{mod } 4)}} &= \phantom{ \{ x \in \mathbb{Z} \mid x \equiv -1 ((\textbf{mod } 4)) \} 
    = \{ x \in \mathbb{Z} \mid x \textbf{ mod } 4 = -1 \textbf{ mod } 4 = 3 \} = \{ 4c+3 \mid c \in \mathbb{Z}\} }
\end{align*}
\[
\mathbb{Z} =  [0]_{R_{(\textbf{mod } 4)}}~ \cup ~[1]_{R_{(\textbf{mod } 4)}} ~\cup~[2]_{R_{(\textbf{mod } 4)}}~\cup~
[3]_{R_{(\textbf{mod } 4)}}
\]





 \vfill
\section*{Modular arithmetic motivation}


Integers are useful because they can be used to encode other objects
and have multiple representations. However, infinite sets are sometimes
expensive to work with computationally. Reducing our attention to 
a {\it partition of the integers} based on congrunce mod $n$, where
each part is represented by a (not too large) integer gives a useful 
compromise where many algebraic properties of the integers are preserved, 
and we also get the benefits of a finite domain. Moreover, modular arithmetic
is well-suited to model any cyclic behavior. \vfill
\section*{Congruence mod n lemma}


{\bf Lemma}: For $a, b \in \mathbb{Z}$ 
and positive integer $n$, $(a,b) \in R_{(\textbf{mod } n)}$ if and only if  $n | a-b$.

{\bf Proof}: 

\phantom{Consider arbitrary integers $a,b$ and arbitrary positive integer $n$.}

\phantom{Assume $a \textbf{ mod } n = b \textbf{ mod } n$. Call this 
remainder $r$ and we have integers $q_1, q_2$ such that $a = q_1 n + r$
and $b = q_2 n + r$. Calculating $a-b = (q_1 n + r) - (q_2n +r) = (q_1 - q_2)n$ 
an integer multiple of $n$, as required.}

\phantom{Assume there is integer $c$ with $a-b = cn$. By long division 
there are integers $q$ and $r$ ($0 \leq r < n$) with $b = qn + r$. Then 
$a = b + cn = qn+r + cn = (q+c)n + r$. Since long division gives a unique remainder,
this means $a \textbf{ mod } n = r = b \textbf{ mod } n$, as required.}

\vspace{200pt} \vfill
\section*{Modular arithmetic}


{\bf Modular arithmetic}: 

{\bf Lemma}: For $a, b, c, d \in \mathbb{Z}$ 
and positive integer $n$, if $a \equiv b ~(\textbf{ mod } n)$ and $c \equiv d ~(\textbf{ mod } n)$ 
then $a+c \equiv b+d ~(\textbf{ mod } n)$ and $ac \equiv bd ~(\textbf{ mod } n)$.
{\bf Informally}: can bring mod ``inside" and do it first, for addition and for multiplication.


$(102 + 48) \textbf{ mod } 10 = \underline{\phantom{\hspace{3in}}} $ 

$(7 \cdot 10) \textbf{ mod } 5 = \underline{\phantom{\hspace{3.3in}}} $ 

$(2^5) \textbf{ mod } 3 =  \underline{\phantom{\hspace{3.45in}}} $ 

\vfill

 \vfill
\section*{Modular arithmetic cycling examples}


{\bf Application: Cycling}

How many minutes past the hour are we at?  \hfill {\it Model with} $+15 \textbf{ mod } 60$

\begin{tabular}{lccccccccccc}
{\bf Time:} &12:00pm  &12:15pm&12:30pm  &12:45pm&1:00pm  &1:15pm&1:30pm  &1:45pm&2:00pm \\
{\bf ``Minutes past":} &$0$ & $15$ & $30$ & $45$ &$0$ & $15$ & $30$ & $45$ &$0$\\
\end{tabular}
\vfill

Replace each English letter by a letter that's fifteen ahead of it in the alphabet
  \hfill {\it Model with} $+15 \textbf{ mod } 26$

{\tiny
\begin{tabular}{lcccccccccccccccccccccccccc}
{\bf Original index:} & $0$ & $1$
 & $2$ & $3$ &  $4$ & $5$ &  $6$ & $7$ &  $8$ & $9$ & $10$ & $11$ & $12$ & $13$ & $14$ & $15$ & 
  $16$ & $17$ &  $18$ & $19$ &  $20$ & $21$ &  $22$ & $23$ & $24$ & $25$\\
{\bf Original letter:} & A & B& C & D & E & F& G& H & I & J & K & L &M & N& O &P &Q & R & S & T & U & V & W & X & Y & Z \\
{\bf Shifted letter}: &P &Q & R & S & T & U & V & W & X & Y & Z & A & B& C & D & E & F& G& H & I & J & K & L &M & N& O \\
{\bf Shifted index:} &$15$ & 
  $16$ & $17$ &  $18$ & $19$ &  $20$ & $21$ &  $22$ & $23$ & $24$ & $25$ & $0$ & $1$
 & $2$ & $3$ &  $4$ & $5$ &  $6$ & $7$ &  $8$ & $9$ & $10$ & $11$ & $12$ & $13$ & $14$ 
\end{tabular}
}
\vfill \vfill
\section*{Equivalence relations partitions}


{\it Recall:} 


A relation is an {\bf equivalence relation} means it is reflexive, symmetric, and transitive. 

An {\bf equivalence class} of an element $a \in A$ 
with respect to an equivalence relation $R$ on the set $A$ is the set 
\[
    \{s \in A \mid (a, s) \in R \}
\] 
We write $[a]_R$ for this set, which is the equivalence class of $a$ with respect to $R$. 

A {\bf partition} of a set $A$ is a set of non-empty, disjoint subsets 
$A_1, A_2, \cdots, A_n$ such that 
\[
    A = \bigcup_{i=1}^{n} A_i = \{ x \mid \exists i (x \in A_i) \}
\] 
{\bf Claim}: For each  $a \in U$, $[a]_{E}  \neq  \emptyset$.

{\bf Proof}: Towards a $\underline{\phantom{\hspace{1.3in}}}$ 
consider an arbitrary element $a$ in $U$. 
We will work to show that $[a]_E \neq \emptyset$, namely that $\exists x \in [a]_E$.
By definition of equivalence classes, we can rewrite this goal as 
$$\exists x \in U ~( ~(a,x) \in E~)$$ 
Towards a $\underline{\phantom{\hspace{1.3in}}}$, consider $x = a$, 
an element of $U$ by definition. By $\underline{\phantom{\hspace{1.3in}}}$ of $E$, 
we know that $(a,a) \in E$  and thus the existential quantification has been proved.\\


{\bf Claim}: For each $a \in U$, there is some $b \in U$  such that $a \in [b]_{E}$.

Towards a $\underline{\phantom{\hspace{1.3in}}}$ 
consider an arbitrary element $a$ in $U$. By definition of equivalence classes, 
we can rewrite the goal as 
$$\exists b \in U ~( ~(b,a) \in E~)$$
Towards a $\underline{\phantom{\hspace{1.3in}}}$, consider $b = a$, 
an element of $U$ by definition. By $\underline{\phantom{\hspace{1.3in}}}$  of $E$, 
we know that $(a,a) \in E$  and thus the existential quantification has been proved. \\
 
{\bf Claim}: For each  $a,b  \in U$ , $(~(a,b)  \in  E ~\to ~ [a]_{E}  = [b]_{E}~)$
and  $(~(a,b)  \notin  E ~\to ~ [a]_{E} \cap[b]_{E} = \emptyset~)$

\phantom{Let $a,b$ be arbitrary. For first goal, assume towards
direct proof that $(a,b) \in E$. To show $[a]_E = [b]_E$ 
first consider arbitrary element $x$ in $[a]_E$. By definition
$(a,x) \in E$ so by symmetry, $(x,a) \in E$ and by 
transitivity with assumption, $(x,b)\in E$. Thus, by definition
of equivalence class, $x \in [b]_E$. Similarly, take arbitrary
element $y \in [b]_E$. By definition $(y,b) \in E$ 
and applying symmetry to assumption, we have $(b,a) \in E$
so by transitivity $(y,a) \in E$ and $y \in[a]_E$, as required
to complete the proof of set equality. For the second goal, 
assume (towards a proof by contrapositive) that $[a]_E \cap [b]_E 
\neq \emptyset$. Then there is a witness $w \in [a]_E \cap [b]_E$.
By definition of equivalence classes $(a,w) \in E$ and $(b,w) \in E$.
By symmetry, we have $(w,b) \in E$ so by transitivity $(a,b) \in E$,
as required.}


\vspace{200pt}

{\bf Corollary}: Given an equivalence relation $E$ on set $U$,  
$\{ [x]_{E} \mid x \in U  \}$ is a partition of $U$.
 \vfill
\section*{Equivalence relations examples ratings}


Recall that 
in a movie recommendation system, each 
user's ratings of movies is represented as a $n$-tuple 
(with the positive integer $n$ 
being the number of movies in the database), 
and each component of 
the $n$-tuple is an element of the collection $\{-1,0,1\}$. 

We call $Rt_5$ the set of all ratings $5$-tuples.

Define $d: Rt_5 \times Rt_5 \to \mathbb{N}$ by
\[
    d (~(~ (x_1, x_2, x_3, x_4, x_5), (y_1, y_2, y_3, y_4, y_5) ~) ~) = \sum_{i=1}^5 |x_i - y_i|
\]

Consider the following binary relations on $Rt_5$.
\[
    E_{proj} =  \{ ( ~(x_1, x_2, x_3, x_4, x_5), (y_1, y_2, y_3, y_4, y_5)~) \in
         Rt_5 \times Rt_5 ~\mid~(x_1 = y_1) \land  (x_2 = y_2) \land (x_3 = y_3) \}
\]

Example ordered pair in $E_{proj}$: 

\vspace{20pt}

Reflexive? Symmetric? Transitive? Antisymmetric?

\vspace{120pt}



\[
    E_{dist} =  \{ (u,v) \in Rt_5 \times Rt_5 ~\mid~ d( ~(u,v)~ ) \leq 2 \}
\]
Example ordered pair in $E_{dist}$: 

\vspace{20pt}

Reflexive? Symmetric? Transitive? Antisymmetric?

\vspace{120pt}


\[
E_{circ} =  \{ (u,v) \in Rt_5 \times Rt_5 ~\mid~ d(~ ( ~(0,0,0,0,0)~, u)~ ) =  d( ~(~(0,0,0,0,0),v~)~) \}
\]
Example ordered pair in $E_{circ}$: 

\vspace{20pt}

Reflexive? Symmetric? Transitive? Antisymmetric?

\vspace{120pt}

The partition of $Rt_5$ defined by $\underline{\phantom{E_{proj}}}$ is

\resizebox{0.9\hsize}{!}{
\begin{math}
\begin{aligned}
    \{ ~~ \{~ &(-1,-1,-1,-1,-1), (-1,-1,-1,-1,0), (-1,-1,-1,-1,1),
     (-1,-1,-1,0,-1), (-1,-1,-1,0,0), (-1,-1,-1,0,1), 
     (-1,-1,-1,1,-1), (-1,-1,-1,1,0), (-1,-1,-1,1,1) ~\},\\
    ~~ \{~ &(-1,-1,0,-1,-1), (-1,-1,0,-1,0), (-1,-1,0,-1,1),
    (-1,-1,0,0,-1), (-1,-1,0,0,0), (-1,-1,0,0,1), 
    (-1,-1,0,1,-1), (-1,-1,0,1,0), (-1,-1,0,1,1) ~\},\\
    ~~ \{~ &(-1,-1,1,-1,-1), (-1,-1,1,-1,0), (-1,-1,1,-1,1),
    (-1,-1,1,0,-1), (-1,-1,1,0,0), (-1,-1,1,0,1), 
    (-1,-1,1,1,-1), (-1,-1,1,1,0), (-1,-1,1,1,1) ~\},\\
    ~~ \{~ &(-1,0,-1,-1,-1), (-1,0,-1,-1,0), (-1,0,-1,-1,1),
    (-1,0,-1,0,-1), (-1,0,-1,0,0), (-1,0,-1,0,1), 
    (-1,0,-1,1,-1), (-1,0,-1,1,0), (-1,0,-1,1,1) ~\},\\
    ~~ \{~ &(-1,0,0,-1,-1), (-1,0,0,-1,0), (-1,0,0,-1,1),
    (-1,0,0,0,-1), (-1,0,0,0,0), (-1,0,0,0,1), 
    (-1,0,0,1,-1), (-1,0,0,1,0), (-1,0,0,1,1) ~\},\\
    ~~ \{~ &(-1,0,1,-1,-1), (-1,0,1,-1,0), (-1,0,1,-1,1),
    (-1,0,1,0,-1), (-1,0,1,0,0), (-1,0,1,0,1), 
    (-1,0,1,1,-1), (-1,0,1,1,0), (-1,0,1,1,1) ~\},\\
    ~~ \{~ &(-1,1,-1,-1,-1), (-1,1,-1,-1,0), (-1,1,-1,-1,1),
    (-1,1,-1,0,-1), (-1,1,-1,0,0), (-1,1,-1,0,1), 
    (-1,1,-1,1,-1), (-1,1,-1,1,0), (-1,1,-1,1,1) ~\},\\
    ~~ \{~ &(-1,1,0,-1,-1), (-1,1,0,-1,0), (-1,1,0,-1,1),
    (-1,1,0,0,-1), (-1,1,0,0,0), (-1,1,0,0,1), 
    (-1,1,0,1,-1), (-1,1,0,1,0), (-1,1,0,1,-1) ~\},\\
    ~~ \{~ &(-1,1,1,-1,-1), (-1,1,1,-1,0), (-1,1,1,-1,1),
    (-1,1,1,0,-1), (-1,1,1,0,0), (-1,1,1,0,1), 
    (-1,1,1,1,-1), (-1,1,1,1,0), (-1,1,1,1,1) ~\},\\
~~ \{~ &(0,-1,-1,-1,-1), (0,-1,-1,-1,0), (0,-1,-1,-1,1),
   (0,-1,-1,0,-1), (0,-1,-1,0,0), (0,-1,-1,0,1), 
   (0,-1,-1,1,-1), (0,-1,-1,1,0), (0,-1,-1,1,1) ~\},\\
  ~~ \{~ &(0,-1,0,-1,-1), (0,-1,0,-1,0), (0,-1,0,-1,1),
  (0,-1,0,0,-1), (0,-1,0,0,0), (0,-1,0,0,1), 
  (0,-1,0,1,-1), (0,-1,0,1,0), (0,-1,0,1,1) ~\},\\
  ~~ \{~ &(0,-1,1,-1,-1), (0,-1,1,-1,0), (0,-1,1,-1,1),
  (0,-1,1,0,-1), (0,-1,1,0,0), (0,-1,1,0,1), 
  (0,-1,1,1,-1), (0,-1,1,1,0), (0,-1,1,1,1) ~\},\\
  ~~ \{~ &(0,0,-1,-1,-1), (0,0,-1,-1,0), (0,0,-1,-1,1),
  (0,0,-1,0,-1), (0,0,-1,0,0), (0,0,-1,0,1), 
  (0,0,-1,1,-1), (0,0,-1,1,0), (0,0,-1,1,1) ~\},\\
  ~~ \{~ &(0,0,0,-1,-1), (0,0,0,-1,0), (0,0,0,-1,1),
  (0,0,0,0,-1),(0,0,0,0,0), (0,0,0,0,1), 
  (0,0,0,1,-1),(0,0,0,1,0), (0,0,0,1,1) ~\},\\
  ~~ \{~ &(0,0,1,-1,-1), (0,0,1,-1,0), (0,0,1,-1,1),
  (0,0,1,0,-1), (0,0,1,0,0), (0,0,1,0,1), 
  (0,0,1,1,-1), (0,0,1,1,0), (0,0,1,1,1) ~\},\\
  ~~ \{~ &(0,1,-1,-1,-1), (0,1,-1,-1,0), (0,1,-1,-1,1),
  (0,1,-1,0,-1), (0,1,-1,0,0), (0,1,-1,0,1), 
  (0,1,-1,1,-1), (0,1,-1,1,0), (0,1,-1,1,1) ~\},\\
  ~~ \{~ &(0,1,0,-1,-1), (0,1,0,-1,0), (0,1,0,-1,1),
  (0,1,0,0,-1), (0,1,0,0,0), (0,1,0,0,1), 
  (0,1,0,1,-1), (0,1,0,1,0), (0,1,0,1,-1) ~\},\\
  ~~ \{~ &(0,1,1,-1,-1), (0,1,1,-1,0), (0,1,1,-1,1),
  (0,1,1,0,-1), (0,1,1,0,0), (0,1,1,0,1), 
  (0,1,1,1,-1), (0,1,1,1,0), (0,1,1,1,1) ~\},\\
~~ \{~ &(1,-1,-1,-1,-1), (1,-1,-1,-1,0), (1,-1,-1,-1,1),
    (1,-1,-1,0,-1),(1,-1,-1,0,0), (1,-1,-1,0,1), 
    (1,-1,-1,1,-1), (1,-1,-1,1,0), (1,-1,-1,1,1) ~\},\\
   ~~ \{~ &(1,-1,0,-1,-1), (1,-1,0,-1,0), (1,-1,0,-1,1),
   (1,-1,0,0,-1), (1,-1,0,0,0), (1,-1,0,0,1), 
   (1,-1,0,1,-1), (1,-1,0,1,0), (1,-1,0,1,1) ~\},\\
   ~~ \{~ &(1,-1,1,-1,-1), (1,-1,1,-1,0), (1,-1,1,-1,1),
   (1,-1,1,0,-1), (1,-1,1,0,0), (1,-1,1,0,1), 
   (1,-1,1,1,-1), (1,-1,1,1,0), (1,-1,1,1,1) ~\},\\
   ~~ \{~ &(1,0,-1,-1,-1), (1,0,-1,-1,0), (1,0,-1,-1,1),
   (1,0,-1,0,-1), (1,0,-1,0,0), (1,0,-1,0,1), 
   (1,0,-1,1,-1), (1,0,-1,1,0), (1,0,-1,1,1) ~\},\\
   ~~ \{~ &(1,0,0,-1,-1), (1,0,0,-1,0), (1,0,0,-1,1),
   (1,0,0,0,-1), (1,0,0,0,0), (1,0,0,0,1), 
   (1,0,0,1,-1), (1,0,0,1,0), (1,0,0,1,1) ~\},\\
   ~~ \{~ &(1,0,1,-1,-1), (1,0,1,-1,0), (1,0,1,-1,1),
   (1,0,1,0,-1), (1,0,1,0,0), (1,0,1,0,1), 
   (1,0,1,1,-1), (1,0,1,1,0), (1,0,1,1,1) ~\},\\
   ~~ \{~ &(1,1,-1,-1,-1), (1,1,-1,-1,0), (1,1,-1,-1,1),
   (1,1,-1,0,-1), (1,1,-1,0,0), (1,1,-1,0,1), 
   (1,1,-1,1,-1), (1,1,-1,1,0), (1,1,-1,1,1) ~\},\\
   ~~ \{~ &(1,1,0,-1,-1), (1,1,0,-1,0), (1,1,0,-1,1),
   (1,1,0,0,-1), (1,1,0,0,0), (1,1,0,0,1), 
   (1,1,0,1,-1), (1,1,0,1,0), (1,1,0,1,-1) ~\},\\
   ~~ \{~ &(1,1,1,-1,-1), (1,1,1,-1,0), (1,1,1,-1,1),
   (1,1,1,0,-1), (1,1,1,0,0), (1,1,1,0,1), 
   (1,1,1,1,-1), (1,1,1,1,0), (1,1,1,1,1) ~\}\\
\} \qquad & \\
\end{aligned}
\end{math}
}

The partition of $Rt_5$ defined by $E = \underline{\phantom{E_{circ}}}$ is

\begin{math}
\begin{aligned}
    \{ ~~  & \\
    &[ ~(0,0,0,0,0)~ ]_E   \\
    &, [ ~(0,0,0,0,1)~ ]_E \\
    &, [ ~(0,0,0,1,1)~ ]_E \\
    &, [ ~(0,0,1,1,1)~ ]_E \\
    &, [ ~(0,1,1,1,1)~ ]_E \\
    &, [ ~(1,1,1,1,1)~ ]_E \\
    \qquad\}  & \\
\end{aligned}
\end{math}

How many elements are in each part of the partition? \vfill
\section*{Netflix clustering scenario}


{\bf Scenario}: Good morning! You're a user experience engineer at Netflix. A
product goal is to design customized home pages for groups of users who have
similar interests. Your manager tasks you with designing an algorithm for
producing a clustering of users based on their movie interests,
so that customized homepages can be engineered for each group.



Your idea: equivalence relations! 


\[
    E_{id} = \{ ( ~(x_1, x_2, x_3, x_4, x_5), (x_1, x_2, x_3, x_4, x_5)~) \mid 
    (x_1, x_2, x_3, x_4, x_5) \in Rt_5  \}
\]

{\it Describe how each homepage should be designed \ldots }

\vspace{100pt}



\[
    E_{proj} =  \{ ( ~(x_1, x_2, x_3, x_4, x_5), (y_1, y_2, y_3, y_4, y_5)~) \in
         Rt_5 \times Rt_5 ~\mid~(x_1 = y_1) \land  (x_2 = y_2) \land (x_3 = y_3) \}
\]


{\it Describe how each homepage should be designed \ldots }

\vspace{100pt}

\[
E_{circ} =  \{ (u,v) \in Rt_5 \times Rt_5 ~\mid~ d(~ ( ~(0,0,0,0,0)~, u)~ ) =  d( ~(~(0,0,0,0,0),v~)~) \}
\]

{\it Describe how each homepage should be designed \ldots }


\vspace{100pt}































%
 \vfill
\section*{Set construction final review}


The bases of RNA strands are elements of the set $B = \{\A, \C, \G, \U \}$. 
The set of RNA strands $S$ is defined (recursively) by:
\[
\begin{array}{ll}
\textrm{Basis Step: } & \A \in S, \C \in S, \U \in S, \G \in S \\
\textrm{Recursive Step: } & \textrm{If } s \in S\textrm{ and }b \in B \textrm{, then }sb \in S
\end{array}
\]
where $sb$ is string concatenation.

Each of the sets below is described using set builder notation. Rewrite them using the roster method. 
\begin{itemize}
\item $\{s \in S ~|~ \text{the leftmost base in $s$ is the same as the rightmost base in $s$ and 
$s$ has length $3$} \}$ 

\vspace{50pt}

\item $\{s \in S ~|~ \text{there are twice as many $\A$s as $\C$s in $s$ and $s$ has length $1$} \}$ 

\vspace{50pt}

\end{itemize}

Certain 
 sequences of bases serve important biological functions in translating RNA to proteins. The following
 recursive definition gives a special set of RNA strands: The set of RNA strands $\hat{S}$ is defined (recursively)
 by 
 
 \begin{alignat*}{2}
\text{Basis step:} & & \A\U\G \in \hat{S}\\
\text{Recursive step:} & \qquad& \text{If } s \in \hat{S} \text{ and } x \in R \text{, then } sx\in \hat{S}\\
 \end{alignat*}
 where $R = \{ \U\U\U, \C\U\C, \A\U\C, \A\U\G, \G\U\U, \C\C\U, \G\C\U, \U\G\G, \G\G\A \}$.

Each of the sets below is described using set builder notation. Rewrite them using the roster method. 
\begin{itemize}
\item $\{s \in \hat{S} ~|~ s \text{ has length less than or equal to $5$} \}$ 

\vspace{50pt}


\item $\{s \in S ~|~ \text{there are twice as many $\C$s as $\A$s in $s$ and $s$ has length $6$} \}$ 

\vspace{50pt}

\end{itemize} \vfill
\section*{Set operations final review}


Let $W = \mathcal{P}( \{ 1,2,3,4,5\})$. Consider the statement 
\[
\forall A \in W~ \forall B \in W ~ \forall C \in W~ ((A \cap B = A \cap C) \to (B=C) )
\]
Translate the statement to English.
Negate the statement 
and translate this negation to English.
Decide whether the original statement or its negation is true
and justify your decision.
 \vfill
\section*{Function properties final review}


The set of linked lists of natural numbers $L$ is defined by 
 \begin{alignat*}{2}
\text{Basis step:} & &[] \in L \\
\text{Recursive step:} & \qquad& \text{If } l \in L \text{ and } n \in \mathbb{N} \text{, then } (n,l) \in L\\
 \end{alignat*}
 The function $length: L \to \mathbb{N}$ that computes the length of a list is
  \begin{alignat*}{2}
\text{Basis step:} & &length([]) = 0\\
\text{Recursive step:} & \qquad& \text{If $l \in L$ and $n \in \mathbb{N}$, then } length( ( n,l) ) = 1 + length(l)\\
 \end{alignat*}

Prove or disprove: the function $length$ is onto.

\vfill

Prove or disprove: the function $length$ is one-to-one.

\vfill
 \vfill
\section*{Cardinality final review}


Suppose $A$ and $B$ are sets and $A \subseteq B$:

{\bf True or False}?  If $A$ is infinite then $B$ is finite.

\vspace{50pt}

{\bf True or False}?  If $A$ is countable then $B$ is countable.

\vspace{50pt}

{\bf True or False}?  If $B$ is infinite then $A$ is finite.

\vspace{50pt}

{\bf True or False}?  If $B$ is uncountable then $A$ is countable.

\vspace{50pt} \vfill
\section*{Modular arithmetic final review}


Compute the last digit of 
\[
    (42)^{2024}
\]

\vfill

{\it Extra} Describe the pattern that helps you perform this computation 
and prove it using mathematical induction. \vfill
\end{document}