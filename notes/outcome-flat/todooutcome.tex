\documentclass[12pt, oneside]{article}

\usepackage[letterpaper, scale=0.89, centering]{geometry}
\usepackage{fancyhdr}
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\rfoot{\href{https://creativecommons.org/licenses/by-nc-sa/2.0/}{CC BY-NC-SA 2.0} Version \today~(\thepage)}

\usepackage{amssymb,amsmath,pifont,amsfonts,comment,enumerate,enumitem}
\usepackage{currfile,xstring,hyperref,tabularx,graphicx,wasysym}
\usepackage[labelformat=empty]{caption}
\usepackage{xcolor}
\usepackage{multicol,multirow,array,listings,tabularx,lastpage,textcomp,booktabs}

\lstnewenvironment{algorithm}[1][] {   
    \lstset{ mathescape=true,
        frame=tB,
        numbers=left, 
        numberstyle=\tiny,
        basicstyle=\rmfamily\scriptsize, 
        keywordstyle=\color{black}\bfseries,
        keywords={,procedure, div, for, to, input, output, return, datatype, function, in, if, else, foreach, while, begin, end, }
        numbers=left,
        xleftmargin=.04\textwidth,
        #1
    }
}
{}
\lstnewenvironment{java}[1][]
{   
    \lstset{
        language=java,
        mathescape=true,
        frame=tB,
        numbers=left, 
        numberstyle=\tiny,
        basicstyle=\ttfamily\scriptsize, 
        keywordstyle=\color{black}\bfseries,
        keywords={, int, double, for, return, if, else, while, }
        numbers=left,
        xleftmargin=.04\textwidth,
        #1
    }
}
{}

\newcommand\abs[1]{\lvert~#1~\rvert}
\newcommand{\st}{\mid}

\newcommand{\A}[0]{\texttt{A}}
\newcommand{\C}[0]{\texttt{C}}
\newcommand{\G}[0]{\texttt{G}}
\newcommand{\U}[0]{\texttt{U}}

\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

 
\begin{document}
\begin{flushright}
    \StrBefore{\currfilename}{.}
\end{flushright} \section*{Cartesian product definition}


{\bf Definition}: The {\bf Cartesian product} of the sets $A$ and $B$, 
$A \times B$, is the set of all ordered pairs $(a, b)$, where $a \in A$ and $b \in B$. 
That is: $A \times B = \{(a, b) \mid (a \in A) \land (b \in B)\}$.
The Cartesian product of the sets $A_1, A_2, \ldots ,A_n$, denoted by 
$A_1 \times A_2 \times \cdots \times A_n$, is the
set of ordered n-tuples $(a_1, a_2,...,a_n)$, where $a_i$ belongs to 
$A_i$ for $i = 1, 2,\ldots,n$. That is,
\[
    A_1 \times A_2 \times \cdots \times A_n = \{(a_1, a_2,\ldots,a_n) \mid a_i \in A_i \textrm{ for } i = 1, 2,\ldots,n\}
\] \vfill
\section*{Rna mutation insertion deletion example}


Trace the pseudocode to find the output of $\textit{mutation}(~ (\A\U\C, 3, \G) ~)$

\vspace{50pt}

Fill in the blanks so that $\textit{insertion}(~(\A\U\C, \underline{\phantom{3}}, \underline{\phantom{\G}})~) = \A\U\C\G$

\vspace{50pt}

Fill in the blanks so that $\textit{deletion}(~(\underline{\phantom{\G\G}}, \underline{\phantom{1}})~) =  \G$

\vspace{50pt}
 \vfill
\section*{Rna rnalen basecount definitions}


{\it Recall the definitions}: The set of RNA strands $S$ is defined (recursively) by:
\[
\begin{array}{ll}
\textrm{Basis Step: } & \A \in S, \C \in S, \U \in S, \G \in S \\
\textrm{Recursive Step: } & \textrm{If } s \in S\textrm{ and }b \in B \textrm{, then }sb \in S
\end{array}
\]
where $sb$ is string concatenation.

The function \textit{rnalen} that computes the length of RNA strands in $S$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{rnalen} : S & \to \mathbb{Z}^+ \\
\textrm{Basis Step:} & \textrm{If } b \in B\textrm{ then } & \textit{rnalen}(b) & = 1 \\
\textrm{Recursive Step:} & \textrm{If } s \in S\textrm{ and }b \in B\textrm{, then  } & \textit{rnalen}(sb) & = 1 + \textit{rnalen}(s)
\end{array}
\]

The function \textit{basecount} that computes the number of a given base 
$b$ appearing in a RNA strand $s$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{basecount} : S \times B & \to \mathbb{N} \\
\textrm{Basis Step:} &  \textrm{If } b_1 \in B, b_2 \in B & \textit{basecount}(~(b_1, b_2)~) & =
        \begin{cases}
            1 & \textrm{when } b_1 = b_2 \\
            0 & \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} & \textrm{If } s \in S, b_1 \in B, b_2 \in B &\textit{basecount}(~(s b_1, b_2)~) & =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 = b_2 \\
            \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 \neq b_2 \\
        \end{cases}
\end{array}
\] \vfill
\section*{Alternating quantifiers order rna examples}


{\bf Alternating nested quantifiers}



$$\forall s \in S ~\exists n \in \mathbb{N} ~(~basecount(~(s,\U)~) = n~)$$

In English: For each strand, there is a nonnnegative integer that counts the number of occurrences of $\U$ in that 
strand.\\

$$\exists n \in \mathbb{N} ~\forall s \in S ~(~basecount(~(s,\U)~) = n~)$$

In English: There is a nonnnegative integer that counts the number of occurrences of $\U$ in every 
strand.\\

\vfill

Are these statements true or false?

\newpage

$$\forall s \in S ~\exists b\in B ~(~basecount(~(s,b)~) = 3~)$$

In English: For each RNA strand there is a base that occurs 3 times in this strand.\\

Write the negation and use De Morgan's law to find a 
logically equivalent version where the negation is applied only to the 
$BC$ predicate (not next to a quantifier).

\vspace{60pt}


Is the original statement {\bf True} or {\bf False}?

\vfill
 \vfill
\section*{Proof strategies quantification finite domain}


When a predicate $P(x)$ is over a {\bf finite} domain:
\begin{itemize}
\item To show that $\forall x  P(x)$ is true: check that $P(x)$ evaluates to $T$ at each domain element by evaluating over and over. 
This is called ``Proof of universal by {\bf exhaustion}".
\item To show that $\forall x  P(x)$ is false: find a {\bf counterexample}, a domain element where $P(x)$~evaluates~to~$F$.
\item To show that $\exists x  P(x)$ is true: find a {\bf witness}, a domain element where $P(x)$ evaluates to $T$.
\item To show that $\exists x  P(x)$ is false: check that $P(x)$ evaluates to $F$ at each domain element by evaluating over and over.
DeMorgan's Law gives that $\lnot \exists x P(x) ~~\equiv~~ \forall x \lnot P(x)$ so this amounts to a proof of universal by exhaustion.
\end{itemize} \vfill
\section*{Proof strategy universal generalization}


\fbox{\parbox{\linewidth}{

{\bf New! Proof by universal generalization}: To prove that $\forall x \, P(x)$
is true, we can take an arbitrary element $e$ from the domain of 
quantification and show that $P(e)$ is true, without making any assumptions about $e$ 
other than that it comes from the domain.


An {\bf arbitrary} element of a set or domain is a fixed but unknown element from that set. 
}}
 \vfill
\section*{Quiz translating counting quantifiers}


Suppose $P(x)$ is  a predicate over a domain $D$.
\begin{enumerate}
    \item True or False: To translate the statement
    ``There are at least two  elements in $D$
    where the predicate $P$ evaluates to true", we
    could  write
    \[
    \exists  x_1 \in D \, \exists x_2 \in D  \, (P(x_1) \wedge P(x_2))
    \]
    \vfill
    \item True or False: To translate the statement
    ``There are at most two  elements in $D$
    where the predicate $P$ evaluates to true", we
    could write
    \[
    \forall  x_1 \in D \, \forall x_2 \in D \, \forall x_3 \in  D \, \left(~ (~P(x_1) \wedge P(x_2)  \wedge P(x_3) ~) \to (~ x_1 = x_2 \vee x_2 = x_3 \vee x_1 = x_3~)~\right)
    \]
    \vfill
\end{enumerate} \vfill
\section*{Proof strategies conditionals}


\fbox{\parbox{\linewidth}{

{\bf New! Proof of conditional by direct proof}: To prove that the conditional statement $p \to q$ is true, 
we can assume $p$ is true and use that assumption to show $q$ is true.
}}

\fbox{\parbox{\linewidth}{

{\bf New! Proof of conditional by contrapositive proof}: To prove that the implication $p \to q$ is true, 
we can assume $q$ is false and use that assumption to show $p$ is also false.
}}

\fbox{\parbox{\linewidth}{

{\bf New! Proof of disjuction using equivalent conditional}: To prove that the 
disjunction $p \lor q$ is true, we can rewrite it equivalently as $\lnot p \to q$ and
then use direct proof or contrapositive proof.
}} \vfill
\section*{Proof strategies proof by cases}


\fbox{\parbox{\linewidth}{{\bf New! Proof by Cases}: To prove $q$, we can 
work by cases by first describing all possible cases we might be in
and then showing that each one guarantees $q$.
Formally, if we know that $p_1 \lor p_2$ is true, 
and we can show that $(p_1 \to q)$ is true and we can show that $(p_2 \to q)$, 
then we can conclude $q$ is true.
}} \vfill
\section*{Proof strategies ands}


\fbox{\parbox{\linewidth}{
{\bf New! Proof of conjunctions with subgoals}:
To show that $p \land q$ is true, we have two subgoals: subgoal (1) prove $p$ 
is  true; and, subgoal (2) prove $q$ is true.

\vspace{1em}

 To show that $p \land q$ is false, it's enough to prove that $\lnot p$.
 
 To show that $p \land q$ is false, it's enough to prove that $\lnot q$.
}} \vfill
\section*{Sets proof strategies}


To prove that one set is a subset of another, e.g. to show $A \subseteq B$:

\vspace{50pt}

To prove that two sets are equal, e.g. to show $A = B$:

\vspace{50pt}
 \vfill
\section*{Sets equality example}


Example: $\{ 43, 7, 9 \} = \{ 7, 43, 9, 7\}$

\vspace{50pt}
 \vfill
\section*{Sets basic proofs}


{\bf Prove} or {\bf  disprove}: $\{ \A,  \C,  \U,  \G\} \subseteq \{ \A\A, \A\C, \A\U, \A\G \}$ 

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: For some set $B$, $\emptyset \in B$.

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: For every set $B$, $\emptyset \in B$.

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: The empty set is a subset of every set.

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: The empty set is a proper subset of every set.

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: $\{ 4, 6 \} \subseteq \{ n \mid  \exists c \in \mathbb{Z} ( n = 4c) \} $

\vspace{150pt}

{\bf Prove} or {\bf  disprove}: $\{ 4, 6 \} \subseteq \{ n ~\textbf{mod}~10 \mid  \exists c \in \mathbb{Z} ( n = 4c) \} $

\vspace{150pt}

 \vfill
\section*{Proofs signposting}


\fbox{\parbox{\textwidth}{

\vspace{10pt}

Consider \ldots, an {\bf arbitrary} \ldots.
{\bf Assume} \ldots, we {\bf want to show} that \ldots. Which is what was needed,
so the proof is complete $\square$.

\vspace{20pt} {\it or, in other words:} \vspace{20pt}

Let \ldots be an {\bf arbitrary} \ldots. {\bf Assume} \ldots, {\bf WTS} that \ldots {\bf QED}.

\vspace{10pt}

}} \vfill
\section*{Set operations union intersection powerset}


{\bf Cartesian product}: When $A$ and  $B$ are sets, 
\[
    A \times  B = \{ (a,b) \mid a \in A  \wedge b  \in B \}
\]

Example: $\{43, 9\} \times  \{9, \mathbb{Z}\}  = $
    
Example: $\mathbb{Z} \times \emptyset  = $

{\bf Union}: When $A$ and  $B$ are sets,
\[
    A \cup  B = \{ x \mid x \in A  \vee x \in B \}
\]    
    
Example: $\{43, 9\} \cup \{9, \mathbb{Z}\}  = $

Example: $\mathbb{Z} \cup \emptyset  = $ 

{\bf Intersection}: When $A$ and  $B$ are sets,
\[
    A \cap  B = \{ x \mid x \in A  \wedge x \in B \}
\]    
Example: $\{43, 9\} \cap \{9,\mathbb{Z}\}  = $

Example: $\mathbb{Z} \cap \emptyset  = $


{\bf Set  difference}: When $A$ and  $B$ are sets,

\[
    A -  B = \{ x \mid x \in A  \wedge x \notin B \}
\]

Example: $\{43, 9\} - \{9, \mathbb{Z}\}  = $

Example: $\mathbb{Z} - \emptyset  = $

    
{\bf Disjoint sets}: sets $A$ and  $B$ are disjoint means $A \cap  B  = \emptyset$

Example: $\{43, 9\}, \{9, \mathbb{Z}\}$ are not  disjoint 

Example: The sets $\mathbb{Z}$ and $\emptyset$ are disjoint

    

{\bf Power set}: When $U$ is a set, $\mathcal{P}(U) = \{ X \mid X \subseteq U\}$

Example: $\mathcal{P}(\{43, 9\}) = $

Example: $\mathcal{P}(\emptyset) = $
 \vfill
\section*{Quantification definition}


The {\bf universal quantification} of predicate $P(x)$ over
domain $U$ is the statement ``$P(x)$ for all values of $x$ in the domain $U$''
and is written $\forall x P(x)$ or $\forall x \in U ~P(x)$. 
When the domain is finite, universal quantification over the domain 
is equivalent to iterated {\it conjunction} (ands).

The {\bf existential quantification} of predicate $P(x)$ 
over domain $U$ is the statement ``There exists an element $x$ 
in the domain $U$ such that $P(x)$'' and is written $\exists x P(x)$
for $\exists x \in U ~P(x)$. 
When the domain is finite, existential quantification over the domain 
is equivalent to iterated {\it disjunction} (ors).

An element for which $P(x) = F$ is called a {\bf counterexample} of $\forall x P(x)$.

An element for which $P(x) = T$ is called a {\bf witness} of $\exists x P(x)$.
 \vfill
\section*{Quantification logical equivalence}


Statements involving predicates and quantifiers are {\bf logically equivalent} 
means they have the same truth value no matter which predicates (domains and functions) 
are substituted in. 

{\bf Quantifier version of De Morgan's laws}: 
$\boxed{\neg \forall x P(x) ~\equiv~ \exists x \left( \neg P(x) \right)}$
\qquad
\qquad
$\boxed{\neg \exists x Q(x) ~\equiv~ \forall x \left( \neg Q(x) \right)}$
 \vfill
\section*{Quantification examples finite domain}


Examples of quantifications using $V(x), N(x), Mystery(x)$:

{\bf True} or {\bf False}: $\exists x~ (~V(x) \land N(x)~)$

\vfill

{\bf True} or {\bf False}: $\forall x~ (~V(x) \to N(x)~)$

\vfill

{\bf True} or {\bf False}: $\exists x~ (~N(x) \leftrightarrow Mystery(x)~)$

\vfill

Rewrite $\lnot \forall x~(~V(x) \oplus Mystery(x)~)$ into a logical equivalent statement.

\vspace{50pt}


Notice that these are examples where the predicates have {\it finite} domain.
How would we evaluate quantifications where the domain may be infinite?

\vfill

 \vfill
\section*{Rna rnalen basecount definitions}


{\it Recall the definitions}: The set of RNA strands $S$ is defined (recursively) by:
\[
\begin{array}{ll}
\textrm{Basis Step: } & \A \in S, \C \in S, \U \in S, \G \in S \\
\textrm{Recursive Step: } & \textrm{If } s \in S\textrm{ and }b \in B \textrm{, then }sb \in S
\end{array}
\]
where $sb$ is string concatenation.

The function \textit{rnalen} that computes the length of RNA strands in $S$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{rnalen} : S & \to \mathbb{Z}^+ \\
\textrm{Basis Step:} & \textrm{If } b \in B\textrm{ then } & \textit{rnalen}(b) & = 1 \\
\textrm{Recursive Step:} & \textrm{If } s \in S\textrm{ and }b \in B\textrm{, then  } & \textit{rnalen}(sb) & = 1 + \textit{rnalen}(s)
\end{array}
\]

The function \textit{basecount} that computes the number of a given base 
$b$ appearing in a RNA strand $s$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{basecount} : S \times B & \to \mathbb{N} \\
\textrm{Basis Step:} &  \textrm{If } b_1 \in B, b_2 \in B & \textit{basecount}(~(b_1, b_2)~) & =
        \begin{cases}
            1 & \textrm{when } b_1 = b_2 \\
            0 & \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} & \textrm{If } s \in S, b_1 \in B, b_2 \in B &\textit{basecount}(~(s b_1, b_2)~) & =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 = b_2 \\
            \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 \neq b_2 \\
        \end{cases}
\end{array}
\] \vfill
\section*{Predicates example rnalen basecount}


{\bf Using functions to define predicates}:

\fbox{\parbox{\textwidth}{
$L$ with domain $S \times \mathbb{Z}^+$ is defined by, for $s \in S$ and $n \in \mathbb{Z}^+$,
\[
L( ~(s, n)~) = \begin{cases}
T &\qquad\text{if $rnalen(s) = n$}\\
F &\qquad\text{otherwise}\\
\end{cases}
\]
In other words, $L(~(s,n)~)$ means $rnalen(s) = n$
}}

\vfill

\fbox{\parbox{\textwidth}{
$BC$ with domain $S \times B \times \mathbb{N}$ is defined by, 
for $s \in S$ and $b \in B$ and $n \in \mathbb{N}$,
\[
BC(~(s, b, n)~) = \begin{cases}
T &\qquad\text{if $basecount(~(s,b)~) = n$}\\
F &\qquad\text{otherwise}\\
\end{cases}
\]
In other words, $BC(~(s,b,n)~)$ means $basecount(~(s,b)~) = n$
}}


\vfill


Example where $L$ evaluates to $T$: $\underline{\phantom{(\A, 1)\hspace{1in}}}$  Why?

\vfill


Example where $BC$ evaluates to $T$: $\underline{\phantom{(\A, \A1)\hspace{1in}}}$  Why?

\vfill


Example where $L$ evaluates to $F$: $\underline{\phantom{(\A, 2)\hspace{1in}}}$ Why?

\vfill


Example where $BC$ evaluates to $F$: $\underline{\phantom{(\A, \C, 1)\hspace{1in}}}$ Why? 

\vfill


\fbox{\parbox{\textwidth}{
\[\exists t ~BC(t) \qquad \qquad 
\exists (s,b,n) \in S \times B \times \mathbb{N}~ (basecount(~(s,b)~) = n)\]

In English: \phantom{There exists an ordered $3$-tuple 
at which the predicate $BC$ evaluates to $T$.}

\vspace{30pt}

Witness that proves this existential quantification is true:\phantom{$(\G\G, \G, 2)$ or $(\G\A\U\G, \G, 2)$)}
}}

\fbox{\parbox{\textwidth}{
\[\forall t ~BC(t) \qquad \qquad 
\forall(s,b,n) \in S \times B \times \mathbb{N} ~(basecount(~(s,b)~) = n)\]

In English:\phantom{For all ordered $3$-tuples
the predicate $BC$ evaluates to $T$.}

\vspace{30pt}

Counterexample that proves this universal quantification is false: \phantom{$(\G\G, \A, 2)$ or $(\G\A\U\G, \G, 3)$)}
}}
 \vfill
\section*{Predicates projecting example rna basecount}


{\bf New predicates from old}
\begin{enumerate}
\item Define the {\bf new} predicate with domain $S \times B$ and rule
\[
basecount(~(s,b)~) = 3
\]
Example domain element where predicate is $T$: \phantom{$(\A\U\A\A, \A)$}\\

\vfill

\item Define the {\bf new} predicate with domain $S \times \mathbb{N}$ and rule
\[
basecount(~(s,\A)~) = n
\]
Example domain element where predicate is $T$: \phantom{$(\A\U\A,2)$}\\

\vfill


\item Define the {\bf new} predicate with domain $S \times B$ and rule
\[
\exists n \in \mathbb{N} ~(basecount(~(s,b)~) = n)
\]
Example domain element where predicate is $T$: \phantom{$(\A\U\A,\A)$}\\

\vfill


\item Define the {\bf new} predicate with domain $S$ and rule
\[
\forall b \in B ~(basecount(~(s,b)~) = 1)
\]
Example domain element where predicate is $T$: \phantom{$\A\C\G\U$}\\

\vfill


\end{enumerate} \vfill
\section*{Nested quantifiers}


{\bf Nested quantifiers}

\fbox{\parbox{\textwidth}{
\[
    \forall s \in S ~\forall b \in B ~\forall n \in \mathbb{N} ~(basecount(~(s,b)~) = n)
\]

In English: \phantom{There exists an ordered $3$-tuple 
at which the predicate $BC$ evaluates to $T$.}

\vspace{30pt}

Counterexample that proves this universal quantification is false:
\phantom{$(\G\G, \G, 3)$ or $(\G\A\U\G, \G, 2)$)}

\vspace{30pt}

}}

\vfill

\fbox{\parbox{\textwidth}{
\[
    ~\forall n \in \mathbb{N} ~\forall s \in S ~\forall b \in B  ~(basecount(~(s,b)~) = n)
\]

In English: \phantom{There exists an ordered $3$-tuple 
at which the predicate $BC$ evaluates to $T$.}

\vspace{30pt}

Counterexample that proves this universal quantification is false:
\phantom{$(\G\G, \G, 3)$ or $(\G\A\U\G, \G, 2)$)}

\vspace{30pt}

}}

\vfill \vfill
\section*{Alternating quantifiers strategies rna examples}


{\bf Alternating nested quantifiers}

\fbox{\parbox{\textwidth}{
$$\forall s \in S ~\exists b\in B ~(~basecount(~(s,b)~) = 3~)$$

In English: For each RNA strand there is a base that occurs 3 times in this strand.\\

Write the negation and use De Morgan's law to find a 
logically equivalent version where the negation is applied only to the 
$BC$ predicate (not next to a quantifier).

\vspace{60pt}


Is the original statement {\bf True} or {\bf False}?

}}

\vfill

\fbox{\parbox{\textwidth}{

$$\exists s \in S ~\forall b \in B ~\exists n \in \mathbb{N} ~(~basecount(~(s,b)~) = n~)$$

In English: There is an RNA strand so that for each base there is some nonnegative
integer that counts the number of occurrences of that base in this strand.\\

Write the negation and use De Morgan's law to find a 
logically equivalent version where the negation is applied only to the 
$BC$ predicate (not next to a quantifier).

\vspace{60pt}


Is the original statement {\bf True} or {\bf False}?

}}

\vfill
 \vfill
\section*{Sets proof strategies}


To prove that one set is a subset of another, e.g. to show $A \subseteq B$:

\vspace{50pt}

To prove that two sets are equal, e.g. to show $A = B$:

\vspace{50pt}
 \vfill
\section*{Sets basic proofs operations}


Let $W =  \mathcal{P}(  \{ 1,2,3,4,5\} )$

Example elements in $W$ are:
\vspace{20pt}


{\bf Prove} or {\bf  disprove}:  $\forall  A \in W\,  \forall B \in W\,  \left( A \subseteq B
~\to ~ \mathcal{P}(A) \subseteq \mathcal{P}(B) \right)$

\vfill
\vfill
\vfill

{\bf Prove} or {\bf  disprove}:  $\forall  A \in W\,  \forall B \in W\,  \left( \mathcal{P}(A)  =\mathcal{P}(B)
~\to ~ A = B \right)$

\vfill
\vfill

{\bf Prove} or {\bf  disprove}:  $\forall  A \in W\,  \forall B \in W\, \forall C  \in W\,  \left( A\cup B  = A \cup  C
~\to ~ B = C \right)$

\vfill
\vfill \vfill
\section*{Proof strategies road map}


We now have propositional and predicate logic that can help us express 
statements about any domain. We will develop proof strategies to 
craft valid argument for proving that such statements are true or disproving
them (by showing they are false). We will practice these strategies with 
statements about sets and numbers, both because they are familiar and because they
can be used to build cryptographic systems. Then we will apply proof strategies
more broadly to prove statements about data structures and machine learning 
applications. \vfill
\section*{Numbers facts}


\begin{enumerate}
    \item Addition and multiplication of real 
    numbers are each commutative and associative. 
    \vspace{25pt}
    \item The product of two positive numbers is positive, of 
    two negative numbers is positive, and of a positive and a negative number is negative.
    \vspace{25pt}
    \item The sum of two integers, the product of two integers, and the 
    difference between two integers are each integers.
    \vspace{25pt}
    \item For every integer $x$ there is no integer strictly between $x$ and $x+1$, 
    \vspace{25pt}
    \item When $x, y$ are positive integers, $xy \geq x$ and $xy \geq y$.
    \vspace{25pt}
\end{enumerate}
 \vfill
\section*{Factoring definition}


{\bf Definition}: When $a$ and $b$ are integers and $a$ is nonzero, 
{\bf $a$ divides $b$} means there is an integer $c$ such that $b = ac$ . 


Symbolically, $F(~(a,b)~) = \phantom{\exists c\in \mathbb{Z}~(b=ac)}$
and is  a predicate over the domain \underline{\phantom{$\mathbb{Z}^{\neq 0} \times \mathbb{Z}$}}


Other (synonymous) ways to say that $F(~(a,b)~)$ is true: 
\begin{center}
$a$ is a {\bf factor} of $b$
\qquad 
$a$ is a {\bf divisor} of $b$
\qquad  $b$ is a {\bf multiple} of $a$
\qquad
$a | b$
\end{center}

When $a$ is a positive integer and $b$ is any integer, $a | b$
exactly when $b \textbf{ mod } a = 0$

When $a$ is a positive integer and $b$ is any integer, $a | b$
exactly $b = a \cdot (b \textbf{ div } a)$ \vfill
\section*{Factoring translation examples}


{\it Translate these quantified statements by matching to English statement on right.}

\begin{multicols}{2}
$\exists a\in \mathbb{Z}^{\neq 0} ~(~F(~(a,a)~)~)$

$\exists a\in \mathbb{Z}^{\neq 0} ~(~\lnot F(~(a,a)~)~)$

$\forall a\in \mathbb{Z}^{\neq 0} ~(~F(~(a,a)~)~)$

$\forall a\in \mathbb{Z}^{\neq 0} ~(~\lnot F(~(a,a)~)~)$


Every nonzero integer is a factor of itself.

No nonzero integer is a factor of itself.

At least one nonzero integer is a factor of itself.

Some nonzero integer is not a factor of itself.
\end{multicols} \vfill
\section*{Factoring basic claims}


{\bf Claim}: Every nonzero integer is a factor of itself.

{\bf Proof}: 


\vspace{150pt}


{\bf Prove} or {\bf Disprove}: There is a nonzero integer that does not divide its square.



\vspace{150pt}

{\bf Prove} or {\bf Disprove}: Every positive factor of a positive integer is less than or equal to it.

\vspace{150pt}
 \vfill
\section*{Factoring basic claims continued}


{\bf Claim}: Every nonzero integer is a factor of itself and 
every nonzero integer divides its square.

\vspace{100pt}
 \vfill
\section*{Factoring even odd}


{\bf Definition}: an integer $n$ is {\bf even} means that there is an integer $a$ such that $n = 2a$; 
an integer $n$ is {\bf odd} means that there is an integer $a$ such that $n = 2a+1$.  Equivalently, 
an integer $n$ is {\bf even} means $n ~\textbf{ mod }~2 = 0$; an integer $n$ is {\bf odd} means $n ~\textbf{ mod }~2 = 1$.  
Also, an integer is even if and only if it is not odd.
 \vfill
\section*{Prime number definition}


{\bf Definition}:  An integer $p$ greater than $1$ is called {\bf prime} means 
the only positive factors of 
$p$ are $1$ and $p$. A positive integer that is greater than $1$ and is not prime 
is called composite. \vfill
\section*{Primes basic claims}


{\it Extra examples}: Use the definition to prove that $1$ is not prime, $2$ is prime, $3$
is prime, $4$ is not prime, $5$ is prime, $6$ is not prime, and $7$ is prime.


{\bf True or False}: The statement ``There are three consecutive positive integers that are prime."

{\it Hint}: These numbers would be of the form $p, p+1, p+2$ (where $p$ is a positive integer).

{\bf Proof}: We need to show \underline{\phantom{$\exists p \in \mathbb{Z}^+ ~(~Pr(p) \land Pr(p+1) \land Pr(p+2)~)$}}

\vspace{200pt}

{\bf True or False}: The statement ``There are three consecutive odd positive integers that are prime."

{\it Hint}: These numbers would be of the form $p, p+2, p+4$ (where $p$ is an odd positive integer).

{\bf Proof}: We need to show \underline{\phantom{$\exists p \in \mathbb{Z}^+ ~(~(p \textbf{ mod } 2 = 1 \land Pr(p) \land Pr(p+2) \land Pr(p+4)~)$}}

\vspace{200pt}
 \vfill
\section*{Rna rnalen basecount definitions}


{\it Recall the definitions}: The set of RNA strands $S$ is defined (recursively) by:
\[
\begin{array}{ll}
\textrm{Basis Step: } & \A \in S, \C \in S, \U \in S, \G \in S \\
\textrm{Recursive Step: } & \textrm{If } s \in S\textrm{ and }b \in B \textrm{, then }sb \in S
\end{array}
\]
where $sb$ is string concatenation.

The function \textit{rnalen} that computes the length of RNA strands in $S$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{rnalen} : S & \to \mathbb{Z}^+ \\
\textrm{Basis Step:} & \textrm{If } b \in B\textrm{ then } & \textit{rnalen}(b) & = 1 \\
\textrm{Recursive Step:} & \textrm{If } s \in S\textrm{ and }b \in B\textrm{, then  } & \textit{rnalen}(sb) & = 1 + \textit{rnalen}(s)
\end{array}
\]

The function \textit{basecount} that computes the number of a given base 
$b$ appearing in a RNA strand $s$ is defined recursively by:
\[
\begin{array}{llll}
& & \textit{basecount} : S \times B & \to \mathbb{N} \\
\textrm{Basis Step:} &  \textrm{If } b_1 \in B, b_2 \in B & \textit{basecount}(~(b_1, b_2)~) & =
        \begin{cases}
            1 & \textrm{when } b_1 = b_2 \\
            0 & \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} & \textrm{If } s \in S, b_1 \in B, b_2 \in B &\textit{basecount}(~(s b_1, b_2)~) & =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 = b_2 \\
            \textit{basecount}(~(s, b_2)~) & \textrm{when } b_1 \neq b_2 \\
        \end{cases}
\end{array}
\] \vfill
\section*{Alternating quantifiers proofs rna examples}


Which proof strategies could be used to prove each of the following statements?

{\it Hint: first translate the statements to English and identify the main logical structure.}

$\forall s \in S~(~rnalen(s) > 0~)$

\vspace{100pt}

$\forall b \in B~\exists s \in S~(~basecount(~(s,b)~)~ > 0~)$

\vspace{100pt}

$\forall s \in S ~\exists b\in B ~(~basecount(~(s,b)~) > 0~)$

\vspace{100pt}

$\exists s \in S \, (\textit{rnalen(s)} = \textit{basecount}(~(s, \A)~)$

\vspace{100pt}

$\forall s \in S \, (\textit{rnalen(s)} \geq \textit{basecount}(~(s, \A)~))$

\vspace{100pt}

 \vfill
\section*{Structural induction motivating example rna}


{\bf Claim} $\forall s \in S ~(~rnalen(s) > 0~)$

{\bf Proof}: Let $s$ be an arbitrary RNA strand. By the recursive definition of $S$,
either $s \in B$ or there is some strand $s_0$ and some base $b$ such that $s = s_0 b$.
We will show that the inequality holds for both cases.

{$\phantom{Basis}$} {\bf Case}: Assume $s \in B$. We need to show $rnalen(s) > 0$. 
By the basis step in the definition of $rnalen$,
$$rnalen(s) = 1$$
which is greater than $0$, as required.

{$\phantom{Recursive}$} {\bf Case}: Assume there is some strand $s_0$ and some base $b$ 
such that $s = s_0 b$. We will show {\it (the stronger claim)} that 
\[
    \forall u \in S ~\forall b \in B ~( ~\textit{rnalen}(u) >0  \to 
    \textit{rnalen}(ub) >0 ~)
\]
Consider an arbitrary RNA strand $u$ and an arbitrary base $b$, and assume towards a
direct proof,$~~{\phantom{ this is the induction hypothesis}}~~$ that
\[
    rnalen(u) > 0
\]
We need to show that $rnalen(ub) > 0$.
\[
    rnalen(ub) = 1 + rnalen (u) > 1 + 0 = 1 > 0
\]
as required. \vfill
\section*{Proof strategies structural induction}


\fbox{\parbox{\textwidth}{{\bf Proof by Structural Induction} 
To prove a universal quantification over a recursively defined set:
\begin{itemize}
    \item[] {\bf Basis Step}:  Show the statement holds for elements specified in the basis step of the definition.
    \item[]  {\bf Recursive Step}:  Show that if the statement is true for each of the elements used to construct
    new elements in the recursive step of the definition, the result holds for these new elements.
    \end{itemize}
}}
     \vfill
\section*{Structural induction example rnalen basecount}


{\bf Claim} $\forall s \in S \, (\textit{rnalen(s)} \geq \textit{basecount}(~(s, \A)~))$:

{\bf Proof}: We proceed by structural induction on the recursively defined set $S$.

{\bf Basis  Case}: We need to prove that 
the inequality holds for each element in the basis step of the recursive
definition of $S$. 
Need to show 
\begin{align*}
          &(~ rnalen(\A) \geq basecount(~(\A, \A)~)~) \land (~ rnalen(\C) \geq basecount(~(\C, \A)~)~) \\
    \land & (~ rnalen(\U) \geq basecount(~(\U, \A)~)~) \land (~ rnalen(\G) \geq basecount(~(\G, \A)~)~)
\end{align*}
We calculate, using the definitions of $rnalen$ and $basecount$:

\vspace{100pt}

{\bf Recursive Case}: We will prove that 
\[
    \forall u \in S ~\forall b \in B ~( ~rnalen(u) \geq basecount(~(u, \A)~) \to 
    rnalen(ub) \geq basecount(~(ub, \A)~)
\]

Consider arbitrary RNA strand $u$ and arbitrary base $b$. Assume, as the {\bf induction hypothesis},
that $rnalen(u) \geq basecount(~(u,\A)~)$. We need to show that $rnalen(ub) \geq basecount(~(ub, \A)~)$.

Using the recursive step in the definition of the function $rnalen$:
\[
    rnalen(ub) = 1 + rnalen(u)
\]
The recursive step in the definition of the function $basecount$ has two cases. We notice that 
$b = \A \lor b \neq \A$ and we proceed by cases.

{\it Case i.} Assume $b = \A$.

Using the first case in the recursive step in the definition of the function $basecount$:
\[
    basecount(~(ub, \A)~) = 1 + basecount(~(u,\A)~)
\]
By the {\bf induction hypothesis}, we know that $basecount(~(u,\A)~) \leq rnalen(u)$ so:
\[
    basecount(~(ub, \A)~) = 1 + basecount(~(u,\A)~) \leq 1 + rnalen(u) = rnalen (ub)
\]
and, thus, $basecount(~(ub,\A)~) \leq rnalen(ub)$, as required.

{\it Case ii.} Assume $b \neq \A$. 

Using the second case in the recursive step in the definition of the function $basecount$:
\[
    basecount(~(ub, \A)~) = basecount(~(u,\A)~)
\]
By the {\bf induction hypothesis}, we know that $basecount(~(u,\A)~) \leq rnalen(u)$ so:
\[
    basecount(~(ub, \A)~) = basecount(~(u,\A)~) \leq rnalen(u) < 1 + rnalen(u) = rnalen (ub)
\]
and, thus, $basecount(~(ub,\A)~) \leq rnalen(ub)$, as required.
 \vfill
\section*{Proofs signposting kinds of claims}


To organize our proofs, it's useful to highlight which claims are most important for 
our overall goals.
We use some terminology to describe different roles statements can have.

{\bf Theorem}: Statement that can be shown to be true, usually an important one.

Less important theorems can be called {\bf proposition}, {\bf fact}, {\bf result}, {\bf claim}.

{\bf Lemma}: A less important theorem that is useful in proving a theorem.
 
{\bf Corollary}: A theorem that can be proved directly after another one has been proved, 
without needing a lot of extra work.

{\bf Invariant}: A theorem that describes a property that is true about an algorithm or 
system no matter what inputs are used.




 \vfill
\section*{Structural induction example robot grid}


\begin{center}
    \includegraphics[width=3in]{../../resources/images/robot-grid.png}
\end{center}
    
{\bf Theorem}: A robot on an infinite 2-dimensional integer grid starts at $(0,0)$ and at each step moves
to diagonally adjacent grid point. This robot can / cannot {\footnotesize({\it circle one})} reach $(1,0)$.


{\bf Definition} The set of positions the robot can visit  $Pos$ is defined by:
\[
\begin{array}{ll}
    \textrm{Basis Step: } & (0,0) \in Pos \\
    \textrm{Recursive Step: } & \textrm{If } (x,y) \in Pos \textrm{, then } \\
    &\phantom{(x+1, y+1), (x+1, y-1), (x-1, y-1), (x-1, y+1)} \textrm{ are also in } Pos
\end{array}
\]

{\it Example elements of $Pos$ are}:
\vspace{20pt}

{\bf Lemma}: $\forall (x,y) \in Pos~~( x+y \textrm{ is an even integer}~)$

{\it Why are we calling this a lemma?}


Proof of theorem using lemma: To show is $(1,0) \notin Pos$. Rewriting the lemma to explicitly 
restrict the domain of the universal, 
we have $\forall (x,y) ~(~ (x,y) \in Pos~~  \to ~~(x+y \textrm{ is an even integer})~)$.  Since
the universal is true, 
$ (~ (1,0) \in Pos~~ \to ~~(1+0 \textrm{ is an even integer})~)$ is a true statement.
Evaluating the conclusion of this conditional statement: 
By definition of long division, since $1 = 0 \cdot 2 + 1$ (where $0 \in \mathbb{Z}$ and 
$1 \in \mathbb{Z}$ and $0 \leq 1 < 2$ mean that $0$ is the quotient and $1$ is the remainder), $1 ~\textrm{\bf mod}~ 2 = 1$ which is not $0$ 
so the conclusion is false.  A true conditional with a false conclusion must have a false hypothesis: $(1,0) \notin Pos$, QED. $\square$

\vspace{20pt}

Proof of lemma by structural induction:

{\bf Basis Step}:

\vspace{100pt}


{\bf Recursive Step}:  Consider arbitrary $(x,y) \in Pos$.  To show is:
\[
(x+y \text{ is an even integer}) \to (\text{sum of coordinates of next position is even integer})
\]
Assume {\bf as the induction hypothesis, IH} that: 


\vspace{400pt} \vfill
\section*{Structural induction example sum of powers}


The set $\mathbb{N}$ is recursively defined.
Therefore, the function $sumPow: \mathbb{N} \to \mathbb{N}$
which computes, for input $i$, the sum of the nonnegative powers of $2$
up to and including exponent $i$ is defined
recursively by

\begin{alignat*}{2}
    \text{Basis step:  } \qquad & sumPow(0) = 1 &\\
    \text{Recursive step:  } & \text{If } x \in \mathbb{N} \text{, then } &sumPow(x+1) = sumPow(x) + 2^{x+1}
\end{alignat*}

$sumPow(0) =$

\vspace{20pt}

$sumPow(1) =$

\vspace{20pt}

$sumPow(2) =$

\vspace{20pt}


Fill in the blanks in the following proof of 
\[
    \forall n \in \mathbb{N}~(sumPow(n) = 2^{n+1} - 1)
\]

{\bf Proof}: Since $\mathbb{N}$ is recursively defined, we proceed by \underline{\phantom{structural induction \hspace{0.3in}}}.

{\bf Basis case}: We need to show that \underline{\phantom{$sumPow(0) = 2^{0+1} - 1$ \hspace{0.2in}}}.
Evaluating each side: $LHS = sumPow(0) = 1$ by the basis case in the recursive definition
of $sumPow$; $RHS = 2^{0+1} - 1 = 2^1 - 1 = 2-1 = 1$. Since $1=1$, the equality holds.

{\bf Recursive case}: Consider arbitrary natural number $n$ and assume, as the 
\underline{\phantom{Induction Hypothesis (IH)}} that $sumPow(n) = 2^{n+1} - 1$. We need to show that
\underline{\phantom{$sumPow(n+1) = 2^{(n+1) + 1} - 1$}}.  Evaluating each side: 
\[
LHS = sumPow(n+1) \overset{\text{rec def}}{=} sumPow(n)  + 2^{n+1}\overset{\text{IH}}{=} (2^{n+1} - 1) + 2^{n+1}.
\]
\[
RHS = 2^{(n+1)+1}- 1 \overset{\text{exponent rules}}{=} 2 \cdot 2^{n+1} -1  = \left(2^{n+1} + 2^{n+1} \right) - 1
\overset{\text{regrouping}}{=}  (2^{n+1} - 1) + 2^{n+1} 
\]
Thus, $LHS = RHS$. The structural induction is complete and we have proved the universal generalization.
$\square$

 \vfill
\section*{Proof strategy mathematical induction}


\fbox{\parbox{\textwidth}{

{\bf Proof by Mathematical Induction}

To prove a universal quantification over the set of all integers greater than
or  equal to some  base integer $b$,

\vspace{-10pt}

\begin{itemize}
\item[] {\bf Basis Step}:  Show the property holds for $b$. 
\item[]  {\bf Recursive Step}:  Consider an arbitrary integer $n$ greater than or  equal to  $b$, assume
    (as the {\bf induction hypothesis})  that the property holds  for $n$, and use  this and
    other facts to  prove that  the property holds for $n+1$.
\end{itemize}

}} \vfill
\section*{Tautology contradiction contingency examples}


Label each of the following as a tautology, contradiction, or contingency.

$p \land p$

\vfill

$p \oplus p$

\vfill

$p \lor p$

\vfill

$p \lor \lnot p$

\vfill

$p \land \lnot p$

\vfill

 \vfill
\section*{Why represent numbers}


Modeling uses data-types that are encoded in a computer.
The details of the encoding impact the efficiency of algorithms
we use to understand the systems we are modeling and the 
impacts of these algorithms on the people using the systems.
Case study: how to encode numbers?

\phantom{
Positional representation with familiar (decimal) number encodings
\vspace{30pt}
}
\vfill \vfill
\section*{Fixed width definition}


{\bf Definition} For $b$ an integer greater than $1$, $w$ a positive integer, 
and $n$ a nonnegative integer
$\underline{\phantom{\hspace{1in}}}$, ~
the {\bf base $b$ fixed-width $w$ expansion of $n$}  is
\[
(a_{w-1} \cdots a_1 a_0)_{b,w}
\]
where  $a_0, a_1, \ldots, a_{w-1}$ are nonnegative integers less than $b$ and
\[
n =  \sum_{i=0}^{w-1} a_{i} b^{i}
\]
 \vfill
\section*{Fixed width example}


\begin{center}
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    Decimal &  Binary  & Binary fixed-width $10$& Binary fixed-width $7$ & Binary fixed-width $4$\\
    $b=10$ & $b=2$ & $b=2$, $w =  10$& $b=2$, $w =  7$& $b=2$, $w =  4$ \\
    \hline 
    &&&&  \\
    $(20)_{10}$&\phantom{$(10100)_{2}$\qquad\qquad}&&  &\\
    &&&&  \\
\hline
    \end{tabular}
    \end{center}
 \vfill
\section*{Fixed width fractional definition}


{\bf Definition} For $b$ an integer greater than $1$, $w$ a positive integer, 
$w'$ a positive  integer, and $x$ a real number the {\bf base $b$ fixed-width 
expansion of $x$ with integer part width $w$  and fractional part width $w'$} is
$(a_{w-1} \cdots a_1 a_0 .  c_{1} \cdots c_{w'})_{b,w,w'}$
where  $a_0, a_1, \ldots, a_{w-1}, c_1, \ldots, c_{w'}$ are nonnegative integers less than $b$ and
$$x \geq \sum_{i=0}^{w-1} a_{i} b^{i} + \sum_{j=1}^{w'}  c_{j} b^{-j} \hfill
\textrm{\qquad and \qquad}
\hfill x < \sum_{i=0}^{w-1} a_{i} b^{i} + \sum_{j=1}^{w'} c_{j} b^{-j} + b^{-w'}$$

\begin{center}
\begin{tabular}{|c|p{5in}|}
\hline
& \\
$3.75$  in fixed-width binary,& \\
integer part width $2$,&\\
 fractional part width $8$ & \\
& \\
& \\
& \\
& \\
\hline
& \\
$0.1$  in fixed-width binary, & \\
integer part width $2$, &\\
 fractional part width $8$ & \\
 & \\
 & \\
 & \\
 & \\
 \hline
\end{tabular}
\end{center}

\vfill

\includegraphics[width=2in]{../../resources/images/ArithmeticDemo.png}

Note: Java uses floating point, not fixed width representation, but similar rounding errors appear in both.
 \vfill
\section*{Negative int expansions}


{\bf Representing negative integers in binary}: Fix a positive integer  width for the representation  $w$, $w >1$.

\begin{tabular}{|cc|p{3.4in}|p{3.7in}|}
\hline
& & To  represent a positive integer $n$ & To represent a negative integer $-n$\\
\hline
&& &  \\
&\parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{Sign-magnitude}}} &
$[ 0a_{w-2} \cdots a_0]_{s,w}$, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$& 
$[1a_{w-2} \cdots a_0]_{s,w}$
, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$\\
&& & \\
&& Example $n=17$, $w=7$:  & Example $-n=-17$, $w=7$: \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
\hline
&&  &  \\
&\parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{2s complement}}} &
$[0a_{w-2} \cdots a_0]_{2c,w}$, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$& $[1a_{w-2} \cdots a_0]_{2c,w}$, where $2^{w-1} - n =  (a_{w-2} \cdots a_0)_{2,w-1}$\\
&& & \\
&& Example $n=17$, $w=7$:  & Example $-n=-17$, $w=7$: \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
&& & \\
\hline
\end{tabular} \vfill
\section*{Calculating 2s complement}


For positive integer $n$, to represent $-n$ in 
$2$s complement with width $w$,
\begin{itemize}
    \item Calculate $2^{w-1} - n$, convert 
    result to binary fixed-width $w-1$, pad 
    with leading $1$, or
    \item Express $-n$ as a sum of powers of $2$, 
    where the leftmost $2^{w-1}$ is negative weight, or
    \item Convert $n$ to binary fixed-width $w$, 
    flip bits, add 1 (ignore overflow)
\end{itemize}

{\it Challenge: use definitions to explain why
each of these approaches works.} \vfill
\section*{Representing zero}


{\bf Representing $0$}:

So far, we have representations for
positive and negative integers. What about $0$?

\begin{tabular}{|cc|p{3.4in}|p{3.7in}|}
   \hline
   & & To  represent a {\bf non-negative} integer $n$ & To represent a {\bf non-positive} integer $-n$\\
   \hline
   && &  \\
   &\parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{Sign-magnitude}}} &
   $[ 0a_{w-2} \cdots a_0]_{s,w}$, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$& 
   $[1a_{w-2} \cdots a_0]_{s,w}$
   , where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$\\
   && & \\
   && Example $n=0$, $w=7$:  & Example $-n=0$, $w=7$: \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
\hline
   &&  &  \\
   &\parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{2s complement}}} &
   $[0a_{w-2} \cdots a_0]_{2c,w}$, where $n =  (a_{w-2} \cdots a_0)_{2,w-1}$& $[1a_{w-2} \cdots a_0]_{2c,w}$, where $2^{w-1} - n =  (a_{w-2} \cdots a_0)_{2,w-1}$\\
   && & \\
   && Example $n=0$, $w=7$:  & Example $-n=0$, $w=7$: \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
   && & \\
\hline
\end{tabular} \vfill
\end{document}